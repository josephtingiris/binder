#!/bin/bash

# add/check/delete/update dns records

# 20181218, jtingiris

#
# Globals
#

PATH=/bin:/usr/bin:/sbin:/usr/sbin

if [ ${#Verbose} -eq 0 ]; then
    declare -i Verbose=4 # WARNING
else
    if [ ${#VERBOSE} -gt 0 ]; then
        if [[ ${VERBOSE} =~ ^[0-9]+$ ]]; then
            Verbose=${VERBOSE}
        fi
    fi
fi
Verbose_Level_Prefix=on

# supported actions
Dns_Actions=()
Dns_Actions+=(add)
Dns_Actions+=(check)
Dns_Actions+=(delete)
Dns_Actions+=(update)

# any machine using this script requires these ...
Dns_Dependencies=()
Dns_Dependencies+=(curl)
Dns_Dependencies+=(egrep)
Dns_Dependencies+=(find)
Dns_Dependencies+=(getent)
Dns_Dependencies+=(grep)
Dns_Dependencies+=(nslookup)
Dns_Dependencies+=(nsupdate)
Dns_Dependencies+=(sed)

# supported records; see nsupdate -T
Dns_Records=()
Dns_Records+=(A)
Dns_Records+=(AAAA)
Dns_Records+=(PTR)

#
# Functions
#

# standard output an 'aborting' message and exit with a non-zero return code
function aborting() {
    local abort_message="${@}"
    printf "\naborting, %s\n\n" "${abort_message}"
    exit 2
}

# standard output config key value from dns.conf
function dnsBackup() {
    local backup_from="$1"
    local backup_to="$2"

    if [ ! -r "${backup_from}" ]; then
        verbose "WARNING: backup from '${backup_from}' failed; file not readable"
        return 1
    fi

    set -o pipefail

    if [ ${#backup_to} -eq 0 ]; then
        backup_to=${Dns_Dir}/backup$(echo "${backup_from}" | sed "s#${Dns_Dir}##g")
        if [ $? -ne 0 ]; then
            aborting "backup from '${backup_from}' failed; failed to sed '${Dns_Dir}'"
        fi
    fi
    backup_to+="-$(date +%Y%m%d)"

    local backup_count=1
    while [ -a "${backup_to}.${backup_count}" ]; do
        let backup_count=${backup_count}+1
    done

    if [ -a "${backup_to}.$((backup_count-1))" ] && [ ! -d "${backup_to}.$((backup_count-1))" ]; then
        diff -q "${backup_from}" "${backup_to}.$((backup_count-1))" &> /dev/null
        if [ $? -eq 0 ]; then
            # no need to backup; files are identical
            return 2
        fi
    fi

    backup_to+=".${backup_count}"

    verbose "DEBUG: backup_from=${backup_from}" 15
    verbose "DEBUG: backup_to=${backup_to}" 15

    local backup_dir
    if [ ! -d "${backup_from}" ]; then
        backup_dir="$(dirname "${backup_to}")"
    else
        backup_dir="${backup_to}"
    fi

    if [ ! -d "${backup_dir}" ]; then
        mkdir -p "${backup_dir}"
        if [ $? -ne 0 ]; then
            aborting "failed to mkdir -p '${backup_dir}'"
        fi
    fi

    if [ ! -w "${backup_dir}" ]; then
        aborting "'${backup_dir}' directory not writable"
    fi

    verbose "DEBUG: backup_dir=${backup_dir}" 10

    if [ -d "${backup_from}" ]; then
        cp -rp "${backup_from}/" "${backup_to}"
        if [ $? -eq 0 ]; then
            return 0
        else
            aborting "cp -rp '${backup_from}/' '${backup_to}/' failed"
        fi
    else
        cp -p "${backup_from}" "${backup_to}"
        if [ $? -eq 0 ]; then
            return 0
        else
            aborting "cp -p '${backup_from}' '${backup_to}/' failed"
        fi
    fi

    aborting "${FUNCNAME} dead code; bug"
}

# standard output config key value from dns.conf
function dnsConfig() {
    local dns_config_key="$1"
    local dns_config_file="$2"

    if [ ${#dns_config_key} -eq 0 ]; then
        return 1
    fi

    if [ ${#dns_config_file} -eq 0 ]; then
        dns_config_file="${Dns_Config_File}"
    fi

    if [ ${#dns_config_file} -eq 0 ]; then
        aborting "configuration file missing; value is empty"
    else
        if [ ! -r "${dns_config_file}" ]; then
            aborting "configuration file missing; '${dns_config_file}' file not readable"
        fi
    fi

    set -o pipefail

    # strip spaces!
    sed -e '/[[:space:]]/s///g' "${dns_config_file}" 2> /dev/null | egrep -e "^${dns_config_key}=" | head -1 | awk -F\# '{print $1}' | sed -nEe 's#.*=(.*).*#\1#p' 2> /dev/null

    # return pipefail result code
    return $?

}

# standard output with consistency
function dnsEcho() {
    local echo_message="${@}"

    if [ "${Dns_Date}" == "0" ]; then
        echo_message="$(date +%F\ %R:%S): ${echo_message}"
    fi

    if [[ "${echo_message^^}" == *":"* ]]; then
        v1="${echo_message%%:*}"
        v1="${v1#"${v1%%[![:space:]]*}"}"
        v1="${v1%"${v1##*[![:space:]]}"}"
        v2="${echo_message#*:}"
        v2="${v2#"${v2%%[![:space:]]*}"}"
        v2="${v2%"${v2##*[![:space:]]}"}"
        printf -v echo_message "%-11b : %b" "${v1}" "${v2}"
        unset v1 v2
    fi

    if [[ "${echo_message^^}" == *"="* ]]; then
        v1="${echo_message%%=*}"
        v1="${v1#"${v1%%[![:space:]]*}"}"
        v1="${v1%"${v1##*[![:space:]]}"}"
        v2="${echo_message#*=}"
        v2="${v2#"${v2%%[![:space:]]*}"}"
        v2="${v2%"${v2##*[![:space:]]}"}"
        printf -v echo_message "%-40b = %b" "${v1}" "${v2}"
        unset v1 v2
    fi

    printf "%b\n" "${echo_message}"
}

# output matching DNS_Zone config key value from dns.conf
function dnsZoneConfig() {
    local dns_zone_config_value="$1"
    local dns_config_file="$2"
    local dns_config_view="$3"

    if [ ${#dns_zone_config_value} -eq 0 ]; then
        return 1
    fi

    if [ ${#dns_config_file} -eq 0 ]; then
        dns_config_file="${Dns_Config_File}"
    fi

    if [ ${#dns_config_file} -eq 0 ]; then
        # is it OK *not* to have a config file?  should be ...
        verbose "ALERT: configuration file missing; value is empty"
        return 1
    else
        if [ ! -r "${dns_config_file}" ]; then
            verbose "ALERT: configuration file missing; '${dns_config_file}' file not readable"
            return 1
        fi
    fi

    verbose "DEBUG: dns_config_file=${dns_config_file}" 20

    if [ ${#dns_config_view} -gt 0 ]; then
        dns_config_view+=","
    fi

    set -o pipefail

    local config_data config_data_rc
    local dns_zone_config_value_dots="${dns_zone_config_value//[^\.]}"
    local dns_zone_config_value_dots=${#dns_zone_config_value_dots}

    while [ ${dns_zone_config_value_dots} -gt 0 ]; do
        verbose "DEBUG: dns_zone_config_value_dots=${dns_zone_config_value_dots} (${dns_zone_config_value})" 17

        # strip spaces!
        config_data=$(sed -e '/[[:space:]]/s///g' "${dns_config_file}" 2> /dev/null | egrep -e "^Dns_Zone=${dns_zone_config_value},${dns_config_view}" | head -1 | awk -F\# '{print $1}' | sed -nEe 's#.*=(.*).*#\1#p' 2> /dev/null)

        # set rc
        config_data_rc=$?

        if [ ${#config_data} -gt 0 ]; then
            break;
        fi
        dns_zone_config_value=${dns_zone_config_value#*.}
        let dns_zone_config_value_dots=${dns_zone_config_value_dots}-1
    done

    echo ${config_data}

    # return pipefail result code
    return ${config_data_rc}

}

# output valid dns zone keyfile
function dnsZoneKeyfile() {
    local dns_zone="$1"
    local dns_server="$2"
    local dns_zone_key="$3"
    local dns_view="$4"

    # only public & private views
    if [ "${dns_view}" != "private" ] && [ "${dns_view}" != "public" ]; then
        dns_view=""
    fi

    local dns_zone_keyfile

    if [ ${#dns_zone} -eq 0 ]; then
        return 1
    fi

    if [ ${#dns_zone_key} -gt 0 ]; then
        if [ -r "${dns_zone_key}" ]; then
            dns_zone_keyfile="${dns_zone_key}"
            dns_zone_key=$(grep ^key.*\{ "${dns_zone_key}" 2> /dev/null | awk '{print $2}' | sed -e '/"/s///g' -e "/'/s///g")
            if [ ${#dns_zone_key} -eq 0 ]; then
                # invalid key, reset
                dns_zone_key="${dns_zone_keyfile}"
                dns_zone_keyfile=""
            fi
        fi
    fi

    local dns_zone_keyfiles nsupdate_key_args

    verbose "DEBUG: dns_zone=${dns_zone}" 15
    verbose "DEBUG: dns_server=${dns_server}" 15
    verbose "DEBUG: dns_view=${dns_view}" 15

    if [ ${#dns_zone_keyfile} -eq 0 ]; then
        dns_zone_keyfiles=()
        if [ ${#dns_zone_key} -eq 0 ] && [ ${#dns_zone_keyfile} -eq 0 ] && [ ${#dns_view} -eq 0 ]; then
            dns_zone_keyfiles=(none)
        fi
        dns_zone_keyfiles+=($(find ${Dns_Dir}/etc -type f -name "named*zone.key" 2> /dev/null | sort -u))
        dns_zone_keyfiles+=($(find /etc -type f -name "named*zone.key" 2> /dev/null | sort -u))
        if [ -r /etc/rndc.key ]; then
            dns_zone_keyfiles+=(/etc/rndc.key)
        fi
        if [ -r /etc/rndc.conf ]; then
            dns_zone_keyfiles+=(/etc/rndc.conf)
        fi
    else
        dns_zone_keyfiles=("${dns_zone_keyfile}")
    fi

    if [ ${#dns_zone_key} -gt 0 ] || [ ${#dns_zone_keyfile} -gt 0 ] || [ ${#dns_view} -gt 0 ]; then
        for dns_zone_keyfile in "${dns_zone_keyfiles[@]}"; do
            [ "${dns_zone_keyfile}" == "" ] && continue

            if [ ${#dns_zone_key} -gt 0 ]; then
                grep "^key.*[$|\"]${dns_zone_key}[$|\"].*{" "${dns_zone_keyfile}" &> /dev/null
                if [ $? -eq 0 ]; then
                    # found matching keyfile
                    break
                fi
            fi

            if [ ${#dns_view} -gt 0 ]; then
                if [[ "${dns_zone_keyfile}" == *".${dns_view}.zone.key"* ]]; then
                    # found matching keyfile
                    if [ ${#dns_zone_key} -eq 0 ]; then
                        dns_zone_key=$(grep ^key.*\{ "${dns_zone_keyfile}" 2> /dev/null | awk '{print $2}' | sed -e '/"/s///g' -e "/'/s///g")
                    fi
                    break
                fi
            fi
        done
    fi

    local dns_zone_key_valid=1 # false

    if [ ${#dns_zone_keyfile} -gt 0 ]; then
        dns_zone_keyfiles=("${dns_zone_keyfile}" none)
    fi

    local local nsupdate_key_args nsupdate_rc nsupdate_script
    for dns_zone_keyfile in "${dns_zone_keyfiles[@]}"; do
        [ "${dns_zone_keyfile}" == "" ] && continue
        verbose "DEBUG: (1) dns_zone_keyfile=${dns_zone_keyfile}" 18

        unset nsupdate_key_args

        if [ "${dns_zone_keyfile}" != "none" ] && [ -r "${dns_zone_keyfile}" ]; then
            nsupdate_key_args="-k ${dns_zone_keyfile}"
        fi

        nsupdate_script="server ${dns_server}\n"
        nsupdate_script+="zone ${dns_zone}\n"
        #nsupdate_script+="debug\n"
        nsupdate_script+="send\n"

        printf "${nsupdate_script}" | nsupdate ${nsupdate_key_args} -t 5 &> /dev/null
        nsupdate_rc=$?

        verbose "DEBUG: nsupdate ${nsupdate_key_args} -t 5 &> /dev/null [${nsupdate_rc}]" 18

        if [ ${nsupdate_rc} -eq 0 ]; then
            # success
            if [ ${#dns_zone_key} -eq 0 ] && [ "${dns_zone_keyfile}" != "none" ] && [ -r "${dns_zone_keyfile}" ]; then
                dns_zone_key=$(grep ^key.*\{ "${dns_zone_keyfile}" 2> /dev/null | awk '{print $2}' | sed -e '/"/s///g' -e "/'/s///g")
            fi
            if [ "${dns_zone_keyfile}" == "none" ]; then
                dns_zone_key=""
                dns_zone_keyfile=""
            fi
            dns_zone_key_valid=0 # true
            break
        fi

    done

    if [ ${#dns_zone_keyfile} -gt 0 ] && [ -r ${dns_zone_keyfile} ] && [ ${dns_zone_key_valid} -eq 0 ]; then
        printf "${dns_zone_keyfile}"
        if [ ${#dns_zone_key} -gt 0 ]; then
            printf ",${dns_zone_key}"
        fi
        printf "\n"
    else
        if [ ${#dns_zone_keyfile} -gt 0 ] && [ ! -r ${dns_zone_keyfile} ]; then
            dns_zone_key_valid=1 # false
        fi
        if [ ${#dns_zone_key} -gt 0 ]; then
            verbose "ALERT: dns server '${dns_server}' rejected dns zone key '${dns_zone_key}'"
        else
            if [ ${#dns_zone_keyfile} -gt 0 ]; then
                verbose "ALERT: dns server '${dns_server}' rejected dns zone key file '${dns_zone_keyfile}'"
            fi
        fi
        dns_zone_key=""
        dns_zone_keyfile=""
    fi

    verbose "DEBUG: dns_zone_key=${dns_zone_key}" 18
    verbose "DEBUG: (2) dns_zone_keyfile=${dns_zone_keyfile}" 18

    return ${dns_zone_key_valid}
}

# output dns zone master based on a valid SOA
function dnsZoneMname() {
    local dns_data="$1"
    local dns_server="$2"

    local lookup_rc

    lookup_rc=1

    local dns_data_dots="${dns_data//[^\.]}"
    local dns_data_dots=${#dns_data_dots}

    local dns_mname
    while [ ${dns_data_dots} -gt 0 ]; do
        verbose "DEBUG: dns_data_dots=${dns_data_dots} (${dns_data})" 17
        #nslookup -type=soa -timeout=3 ${dns_data} ${dns_server} &> /dev/null
        dns_mname=$(host -t soa -W 3 ${dns_data} ${dns_server} 2> /dev/null | head -1 | grep has\ SOA\ record | awk '{print $5}')
        if [ ${#dns_mname} -ne 0 ]; then
            lookup_rc=0
            break
        fi
        dns_data=${dns_data#*.}
        let dns_data_dots=${dns_data_dots}-1
    done

    verbose "DEBUG: dns_data=${dns_data}, lookup_rc=${lookup_rc}" 17

    if [ ${#dns_mname} -gt 0 ]; then
        echo "${dns_mname}"
        return 0
    fi

    return 1

}

# output dns zone based on a valid SOA
function dnsZoneSOA() {
    local dns_data="$1"
    local dns_server="$2"

    local lookup_rc

    local dns_data_dots="${dns_data//[^\.]}"
    local dns_data_dots=${#dns_data_dots}

    while [ ${dns_data_dots} -gt 0 ]; do
        verbose "DEBUG: dns_data_dots=${dns_data_dots} (${dns_data})" 17
        #nslookup -type=soa -timeout=3 ${dns_data} ${dns_server} &> /dev/null
        host -t soa -W 3 ${dns_data} ${dns_server} &> /dev/null
        lookup_rc=$?
        if [ ${lookup_rc} -eq 0 ]; then
            break
        fi
        dns_data=${dns_data#*.}
        let dns_data_dots=${dns_data_dots}-1
    done

    verbose "DEBUG: dns_data=${dns_data}, lookup_rc=${lookup_rc}" 17

    if [ ${lookup_rc} -eq 0 ] && [ ${#dns_data} -gt 0 ]; then
        echo "${dns_data}"
        return 0
    fi

    return 1

}

# output a 'usage' message and exit with a non-zero return code
function usage() {
    printf "\nusage: %s <action> <record> <name> <data; eg. cname, ip, or txt> [-t <ttl>] [-p <priority>] [-s <server>] [-k <key>] [--help]\n\n" "${0}"

    if [ "${Dns_Actions}" != "" ]; then
        printf "supported actions:\n\n"
        let Dns_Action_Count=0
        for Dns_Action in ${Dns_Actions[@]}; do
            if [ ${Dns_Action_Count} -eq 0 ]; then
                printf "    ${Dns_Action}"
            else
                printf ", ${Dns_Action}"
            fi
            let Dns_Action_Count=${Dns_Action_Count}+1
        done
        printf "\n\n"
        unset Dns_Action
    fi

    if [ "${Dns_Records}" != "" ]; then
        printf "supported records:\n\n"
        let Dns_Record_Count=0
        for Dns_Record in ${Dns_Records[@]}; do
            if [ ${Dns_Record_Count} -eq 0 ]; then
                printf "    ${Dns_Record}"
            else
                printf ", ${Dns_Record}"
            fi
            let Dns_Record_Count=${Dns_Record_Count}+1
        done
        printf "\n\n"
        unset Dns_Record
    fi

    if [ ${#1} -ne 0 ]; then
        local usage_message="${@}"
        printf "NOTE: %s\n\n" "${usage_message}"
    fi
    exit 1
}

if [ "$(type -t verbose)" != "function" ]; then
    function verbose() {
        local verbose_arguments=($@)
        local verbose_level verbose_message

        if [ ${#2} -gt 0 ]; then
            verbose_message=(${verbose_arguments[@]}) # preserve verbose_arguments
            verbose_level=${verbose_message[${#verbose_message[@]}-1]}
        else
            verbose_message="${1}"
            verbose_level=""
        fi

        if [[ ! ${verbose_level} =~ ^[0-9]+$ ]]; then
            verbose_level=0
        fi

        if [[ ${Verbose} =~ ^[0-9]+$ ]]; then
            if [ ${verbose_level} -le ${Verbose} ]; then
                (>&2 printf "%b\n" "${verbose_message}")
            fi
        fi
    }
fi

#
# Main
#

verbose "Verbose = ${Verbose}" 7

Failure_Reason=""

Dns_Basename=$(basename $0)
verbose "INFO: Dns_Basename=${Dns_Basename}"

#
# validate dns directory
#

# dns.conf must exist?

if [ -r "/etc/dns.conf" ]; then
    Dns_Config_File="/etc/dns.conf"
fi

if ! Dns_Dir=$(dnsConfig Dns_Dir); then
    Dns_Dir=$(dirname "$(readlink -e "$0")")
fi

if [ -d "${Dns_Dir}/../zone" ] && [ -r "${Dns_Dir}/../zone" ]; then
    Dns_Dir=$(dirname "${Dns_Dir}")
fi

if [ ${#Dns_Dir} -eq 0 ]; then
    aborting "dns directory value is empty"
fi

if [ ! -d "${Dns_Dir}" ] || [ ! -r "${Dns_Dir}" ]; then
    aborting "dns directory; '${Dns_Dir}' directory not readable"
fi

if [ -f "${Dns_Dir}/etc/named.primary.conf" ] && [ -f "${Dns_Dir}/etc/named.secondary.conf" ]; then
    if [ ${#Dns_Config_File} -eq 0 ] && [ -r "${Dns_Dir}/etc/dns.conf" ]; then
        Dns_Config_File="${Dns_Dir}/etc/dns.conf"
    fi
    if [ -r /etc/named.conf ]; then
        # primary & secondary servers using this script additionally require these ...
        Dns_Dependencies+=(rndc)
    fi
fi

verbose "INFO: Dns_Dir=${Dns_Dir}"

PATH=${Dns_Dir}/bin:${Dns_Dir}/sbin:${PATH}

#
# validate dependencies
#

for Dns_Dependency in ${Dns_Dependencies[@]}; do
    verbose "Dns_Dependency=${Dns_Dependency}" 17
    [ ${#Dns_Dependency} -eq 0 ] && continue
    Dns_Dependency_Exec=$(type -P "${Dns_Dependency}")
    if [ ! -f "${Dns_Dependency_Exec}" ] && [ ! -x "${Dns_Dependency_Exec}" ]; then
        aborting "dependency missing; '${Dns_Dependency}' file not executable"
    fi
done
unset Dns_Dependency Dns_Dependency_Exec

#
# validate BASH_SOURCE
#

# for reusable functions; return if this script was sourced
if [ "${BASH_SOURCE}" != "${0}" ]; then
    if [ ${#Dns_Config_File} -eq 0 ]; then
        aborting "dns.conf file not found"
    fi
    return
else
    # first four arguments are required
    if [ ${#1} -eq 0 ] || [ ${#2} -eq 0 ] || [ ${#3} -eq 0 ] || [ ${#4} -eq 0 ]; then
        usage
    fi
fi

#
# validate action
#

Dns_Action_Valid=1
for Dns_Action in ${Dns_Actions[@]}; do
    if [ "${1,,}" == "${Dns_Action}" ]; then
        Dns_Action_Valid=0
        break
    fi
done
if [ ${Dns_Action_Valid} -eq 1 ]; then
    usage "invalid action '${1}'"
else
    shift
fi
verbose "INFO: Dns_Action=${Dns_Action}"

#
# validate record
#

Dns_Record_Valid=1
for Dns_Record in ${Dns_Records[@]}; do
    if [ "${1^^}" == "${Dns_Record}" ]; then
        Dns_Record_Valid=0
        break
    fi
done
if [ ${Dns_Record_Valid} -eq 1 ]; then
    usage "invalid record '${1}'"
else
    shift
fi
verbose "INFO: Dns_Record=${Dns_Record}"

#
# validate name; set default zone & fqdn
#

Dns_Name=$(echo "$1" | sed -e 's#\.\.*#\.#g' -e 's#^\.##g' -e 's#\.$##g');

if [ ${#Dns_Name} -eq 0 ]; then
    aborting "invalid dns name '$1'"
else
    shift
fi

Dns_Name_Dots="${Dns_Name//[^\.]}"
Dns_Name_Dots=${#Dns_Name_Dots}

if [ ${Dns_Name_Dots} -eq 0 ]; then
    # should default be the first in the resolv.conf search list?
    # first, try to set default zone from dns.conf
    Dns_Zone_Default=$(dnsConfig Dns_Zone_Default | sed -e 's#\.\.*#\.#g' -e 's#^\.##g' -e 's#\.$##g');
    if [ ${#Dns_Zone_Default} -eq 0 ]; then
        # second, try to use /etc/resolv.conf
        if [ -r /etc/resolv.conf ]; then
            Dns_Zone_Default=$(grep ^search\  /etc/resolv.conf 2> /dev/null | head -1 | awk '{print $2}')
        fi
        if [ ${#Dns_Zone_Default} -eq 0 ]; then
            verbose "Dns_Zone_Default is NOT set, using localdomain" 4
            Dns_Zone_Default=localdomain
        fi
    fi

    if [ ${#Dns_Zone_Default} -gt 0 ]; then
        Dns_FQDN=${Dns_Name}.${Dns_Zone_Default}
    else
        Dns_FQDN="${Dns_Name}"
    fi
else
    Dns_FQDN="${Dns_Name}"
fi

if [ "${Dns_Name}" != "${Dns_FQDN}" ]; then
    verbose "INFO: Dns_Name=${Dns_Name} (${Dns_Name_Dots} dots)"
fi

if [ ${#Dns_FQDN} -eq 0 ]; then
    aborting "unable to determine fully qualified domain name"
else
    verbose "NOTICE: Dns_FQDN=${Dns_FQDN}"
fi

#
# validate dns data
#

Dns_Data="$1"
shift

if [ "${Dns_Record}" == "A" ]; then
    if ! (ipcalc -c -4 "${Dns_Data}" &> /dev/null); then
        aborting "${Dns_Data} is an invalid IPv4 address"
    fi
fi

if [ "${Dns_Record}" == "AAAA" ]; then
    if ! (ipcalc -c -6 "${Dns_Data}" &> /dev/null); then
        aborting "${Dns_Data} is an invalid IPv6 address"
    fi
fi

if [ "${Dns_Record}" == "PTR" ]; then
    if (ipcalc -c -4 "${Dns_Data}" &> /dev/null); then
        Dns_FQDN=$(echo ${Dns_Data} | awk -F\. '{print $4"."$3"."$2"."$1".in-addr.arpa"}')
    else
        if (ipcalc -c -6 "${Dns_Data}" &> /dev/null); then
            # ip6.arpa
            aborting "${Dns_Data} IPv6 PTR not supported (yet)"
        else
            aborting "${Dns_Data} is an invalid IP address"
        fi
    fi
fi

verbose "INFO: Dns_Data=${Dns_Data}"

#
# parse cli options
#

# translate long options to short
for arg; do
    quote=""
    case "${arg}" in
        -help|--help)
            args="${args}-h "
            ;;
        -key|--key)
            args="${args}-k "
            ;;
        -priority|--priority)
            args="${args}-p "
            ;;
        -server|--server)
            args="${args}-s "
            ;;
        -ttl|--ttl)
            args="${args}-t "
            ;;
        -view|--view)
            args="${args}-v "
            ;;
        *)
            [[ "${arg:0:1}" == "-" ]] || quote="\""
            args="${args}${quote}${arg}${quote} "
            ;;
    esac
done
eval set -- ${args}

# process short options
while getopts ":hk:p:s:t:v:" option; do
    case "${option}" in
        h)
            usage
            ;;
        k)
            Dns_Zone_Key=${OPTARG}
            ;;
        p)
            Dns_Data_Priority=${OPTARG}
            ;;
        s)
            Dns_Server=${OPTARG}
            ;;
        t)
            Dns_Data_TTL=${OPTARG}
            ;;
        v)
            Dns_View=${OPTARG}
            ;;
        :)
            aborting "option '-${OPTARG}' requires an argument"
            ;;
        *)
            aborting "unknown option '${@}'"
            ;;
    esac
done

#
# validate priority
#

if [[ ! ${Dns_Data_Priority} =~ ^[0-9]+$ ]]; then
    Dns_Data_Priority=10
fi

verbose "INFO: Dns_Data_Priority=${Dns_Data_Priority}"

#
# validate ttl
#

if [[ ! ${Dns_Data_TTL} =~ ^[0-9]+$ ]]; then
    Dns_Data_TTL=60
fi

verbose "INFO: Dns_Data_TTL=${Dns_Data_TTL}"

#
# validate view
#

# dns view is optional; the default view will be whatever the remote named assigns to the dns server ip
if [ ${#Dns_View} -gt 0 ]; then
    verbose "INFO: Dns_View=${Dns_View}"
fi

#
# validate (authoritative) dns server
#

# no dns server given; (attempt to) obtain from dns config
if [ ${#Dns_Server} -eq 0 ]; then
    if Dns_Zone_Config=$(dnsZoneConfig ${Dns_FQDN} ${Dns_Config_File} ${Dns_View}); then
        verbose "DEBUG: Dns_Zone_Config=${Dns_Zone_Config}" 13

        [ ${#Dns_Zone} -eq 0 ] && Dns_Zone=$(echo "${Dns_Zone_Config}" | awk -F, '{print $1}')
        [ ${#Dns_View} -eq 0 ] && Dns_View=$(echo "${Dns_Zone_Config}" | awk -F, '{print $2}')
        [ ${#Dns_Server} -eq 0 ] && Dns_Server=$(echo "${Dns_Zone_Config}" | awk -F, '{print $3}')
        if [[ "${Dns_Server}" == *";"* ]]; then
            Dns_Server=${Dns_Server%%;*}
        fi
        [ ${#Dns_Zone_Key} -eq 0 ] && Dns_Zone_Key=$(echo "${Dns_Zone_Config}" | awk -F, '{print $4}')
    else
        verbose "ALERT: Dns_Zone for '${Dns_FQDN}', view '${Dns_View}' not configured in '${Dns_Config_File}'"
        #aborting "dynamic zones not supported (yet)"
    fi
fi

if [ ${#Dns_Server} -eq 0 ]; then
    Dns_Server=$(dnsZoneMname "${Dns_FQDN}")
fi

if [ ${#Dns_Server} -eq 0 ]; then
    aborting "can't determine authoritative dns server for '${Dns_FQDN}'"
fi

Dns_Server_IP=$(getent ahosts ${Dns_Server} 2> /dev/null | grep STREAM | head -1 | awk '{print $1}')
if [ ${#Dns_Server_IP} -eq 0 ]; then
    aborting "can't determine ip address for autoritative dns server '${Dns_Server}' (no a/cname record for mname?)"
fi

verbose "NOTICE: Dns_Server=${Dns_Server} (${Dns_Server_IP})"

#
# validate dns zone
#

if [ ${#Dns_Zone} -eq 0 ]; then
    Dns_Zone=$(dnsZoneSOA "${Dns_FQDN}" "${Dns_Server}")
fi

if [ ${#Dns_Zone} -eq 0 ]; then
    aborting "can't determine dns zone for '${Dns_FQDN}'"
fi

verbose "INFO: Dns_Zone=${Dns_Zone}"

#
# validate dns zone key
#

if Dns_Zone_Keyfile=$(dnsZoneKeyfile "${Dns_Zone}" "${Dns_Server}" "${Dns_Zone_Key}" "${Dns_View}"); then
    Dns_Zone_Key=${Dns_Zone_Keyfile##*,}
    Dns_Zone_Keyfile=${Dns_Zone_Keyfile%%,*}
else
    aborting "no valid dns zone keys for '${Dns_Zone}'"
fi

verbose "INFO: Dns_Zone_Key=${Dns_Zone_Key}"
verbose "INFO: Dns_Zone_Keyfile=${Dns_Zone_Keyfile}"

#
# final validation
#

if [ ! -d "${Dns_Dir}" ] || [ ! -r "${Dns_Dir}" ]; then
    aborting "'${Dns_Dir}' directory not readable"
fi

if [ ${#Dns_Action} -eq 0 ]; then
    aborting "Dns_Action is empty"
fi

if [ ${#Dns_Record} -eq 0 ]; then
    aborting "Dns_Record is empty"
fi

if [ ${#Dns_FQDN} -eq 0 ]; then
    aborting "Dns_FQDN is empty"
fi

if [ ${#Dns_Data} -eq 0 ]; then
    aborting "Dns_Data is empty"
fi

if [[ ! ${Dns_Data_Priority} =~ ^[0-9]+$ ]]; then
    aborting "Dns_Data_Priority is not an integer"
fi

if [[ ! ${Dns_Data_TTL} =~ ^[0-9]+$ ]]; then
    aborting "Dns_Data_TTL is not an integer"
fi

if [ ${#Dns_Server} -eq 0 ]; then
    aborting "Dns_Server is empty"
fi

if [ ${#Dns_Zone} -eq 0 ]; then
    aborting "Dns_Zone is empty"
fi

#
# validateion complete
#



usage

#
# End
#

exit

verbose "DEBUG: Dns_Zone_Default=${Dns_Zone_Default}"

function nslookup() {

    local verbose_function
    if [ ${Verbose} -gt 3 ]; then
        printf -v verbose_function "%-18s" "${FUNCNAME}"
    fi

    local nslookup=$(type -P nslookup)
    if [ ${#nslookup} -eq 0 ] || [ ! -x "${nslookup}" ]; then
        Failure_Reason="nslookup not executable"
        verbose "CRITICAL  : ${verbose_function}${Failure_Reason}"
        return 1
    fi

    local -i nslookup_rc=1

    ${nslookup} $@ ${Dns_Resolver}
    nslookup_rc=$?

    if [ ${nslookup_rc} -ne 0 ]; then
        Failure_Reason="nslookup failed with rc=${nslookup_rc}"
        verbose "CRITICAL  : ${verbose_function}${Failure_Reason}"
    fi

    return ${nslookup_rc}
}


# 1=name, 2=ip, 3=server[:port], 4=key file
function nsupdatePTR() {

    local verbose_function
    if [ ${Verbose} -gt 3 ]; then
        printf -v verbose_function "%-18s" "${FUNCNAME}"
    fi

    checkGlobals

    local dns_name="$1"

    if [ ${#dns_name} -eq 0 ]; then
        Failure_Reason="dns name is empty"
        verbose "CRITICAL  : ${verbose_function}${Failure_Reason}"
        return 1
    fi

    if (ipcalc -c -4 "${dns_name}" &> /dev/null); then
        Failure_Reason="dns name can not be an ipv4 address"
        verbose "CRITICAL  : ${verbose_function}${Failure_Reason}"
        return 1
    else
        if (ipcalc -c -6 "${dns_name}" &> /dev/null); then
            Failure_Reason="dns name can not be an ipv6 address"
            verbose "CRITICAL  : ${verbose_function}${Failure_Reason}"
            return 1
        fi
    fi

    local dns_data="$2" # ip address
    if (ipcalc -c -4 "${dns_data}" &> /dev/null); then
        dns_data=${dns_data%%/*} # everything before /
    else
        if (ipcalc -c -6 "${dns_data}" &> /dev/null); then
            dns_data=${dns_data%%/*} # everything before /
        else
            Failure_Reason="dns data '${dns_data}' is not an ip address"
            verbose "CRITICAL  : ${verbose_function}${Failure_Reason}"
            return 1
        fi
    fi

    local dns_mname dns_origin dns_zone
    dns_origin=${dns_data}
    if dns_origin=$(nslookupOrigin ${dns_origin}); then
        dns_zone=${dns_origin%%,*} # everything before ,
    else
        dns_origin=${dns_data}
        if dns_origin=$(nslookupOrigin ${dns_origin}); then
            dns_zone=${dns_origin%%,*} # everything before ,
        else
            Failure_Reason="'dns_zone' NOT found for ... '${dns_data}'"
            verbose "CRITICAL  : ${verbose_function}${Failure_Reason}"
            return 1
        fi
    fi
    unset -v dns_mname dns_origin

    local dns_server="$3"
    local dns_mname dns_origin
    if [ ${#dns_server} -eq 0 ]; then

        if [ ${#Dns_Server} -ne 0 ]; then
            dns_server=${Dns_Server}
        else

            dns_origin=${dns_name}
            if dns_origin=$(nslookupOrigin ${dns_origin}); then
                dns_server=${dns_origin##*,} # everything after ,
                dns_zone=${dns_origin%%,*} # everything before ,
            else
                dns_origin=${dns_name}
                if dns_origin=$(nslookupOrigin ${dns_origin}); then
                    dns_server=${dns_origin##*,} # everything after ,
                    dns_zone=${dns_origin%%,*} # everything before ,
                else
                    verbose "WARNING   : ${verbose_function}'${dns_data}' NOT found for ... '${dns_data}'"
                fi
            fi
        fi

    fi
    unset -v dns_mname dns_origin

    #nslookupOrigin "${dns_data}"

    if ! (ipcalc -c -6 "${dns_server}" &> /dev/null); then
        dns_server_port=${dns_server##*:}
        if [ "${dns_server_port}" == "${dns_server}" ]; then
            dns_server_port=53
        else
            dns_server=${dns_server%%:*}
        fi
    fi
    if [ ${#dns_server_port} -eq 0 ]; then
        dns_server_port=53
    fi

    verbose "DEBUG     : ${verbose_function}'${dns_name}' dns_server=${dns_server}:${dns_server_port} dns_zone=${dns_zone} dns_data=${dns_data}"

    local dns_key="$4"

    # done with argument processing, do some more variable validation ...

    local dns_type="PTR"
    local dns_class="IN"
    local dns_ttl=60

    if [ ${#dns_name} -gt 0 ] && [ ${#dns_zone} -gt 0 ]; then

        local dns_ptr

        dns_ptr=$(echo ${dns_data} | awk -F\. '{print $4"."$3"."$2"."$1".in-addr.arpa"}')

        local nsupdate_key nsupdate_key_args
        nsupdateKey "${dns_ptr}" "${dns_server}" "${dns_server_port}" "${dns_key}"
        nsupdate_key=${Nsupdate_Keyfile}
        if [ "${nsupdate_key}" != "none" ] && [ "${nsupdate_key}" != "" ]; then
            nsupdate_key_args="-k ${nsupdate_key}"
        fi
        dns_key=${nsupdate_key}
        unset nsupdate_key

        if [ ${#dns_key} -eq 0 ]; then
            Failure_Reason="'${dns_name}' valid dns key NOT found for '${dns_server}:${dns_server_port}'"
            verbose "CRITICAL  : ${verbose_function}${Failure_Reason}"
            return 1
        fi

        local dns_action
        if [ "${Dns_Add}" == "0" ] && [ "${Dns_Delete}" == "0" ]; then
            dns_action="reverse update (delete & add)"
        else
            if [ "${Dns_Add}" == "0" ]; then
                dns_action="reverse add"
            else
                if [ "${Dns_Delete}" == "0" ]; then
                    dns_action="reverse delete"
                else
                    Failure_Reason="'${dns_name}' dns action is empty"
                    verbose "CRITICAL  : ${verbose_function}${Failure_Reason}"
                    return 1
                fi
            fi
        fi

        printf "\n"
        printf "%-10s = %-32s %20s\n" "dns_action" "${dns_action}" ""
        #printf "%-10s = %-32s %20s\n" "dns_name" "${dns_name}" "(${dns_type}) ${dns_data}"
        printf "%-10s = %-32s %20s\n" "dns_ptr" "${dns_ptr}" "(${dns_type}) ${dns_name}"
        printf "%-10s = %-32s %20s\n" "dns_zone" "${dns_zone}" "${dns_server}:${dns_server_port}"
        printf "%-10s = %-32s %20s\n" "dns_key" "${dns_key}" ""
        printf "\n"

        if [ "${Dns_Delete}" == "0" ]; then
            (
            #printf "%s\n" "debug"
            printf "server %s %s\n" "${dns_server}" "${dns_server_port}"
            if [ ${#dns_zone} -gt 0 ]; then
                printf "zone %s\n" "${dns_zone}"
            fi
            printf "del %s %s\n" "${dns_ptr}" "${dns_type}"
            printf "%s\n" "send"
            #printf "%s\n" "answer"
            ) | nsupdate ${nsupdate_key_args} -t 60 &> /dev/null
            dns_delete_rc=$?
        else
            dns_delete_rc=0
        fi

        if [ "${Dns_Add}" == "0" ] && [ ${dns_delete_rc} -eq 0 ]; then
            (
            #printf "%s\n" "debug"
            printf "server %s %s\n" "${dns_server}" "${dns_server_port}"
            if [ ${#dns_zone} -gt 0 ]; then
                printf "zone %s\n" "${dns_zone}"
            fi
            printf "add %s %s %s %s %s\n" "${dns_ptr}" "${dns_ttl}" "${dns_type}" "${dns_name}"
            printf "%s\n" "send"
            #printf "%s\n" "answer"
            ) | nsupdate ${nsupdate_key_args} -t 60 #&> /dev/null
            dns_add_rc=$?
        else
            dns_add_rc=0
        fi

    fi

    if [ ${dns_add_rc} -eq 0 ] && [ ${dns_delete_rc} -eq 0 ]; then
        verbose "DEBUG     : ${verbose_function}dns_delete_rc = ${dns_delete_rc}"
        verbose "DEBUG     : ${verbose_function}dns_add_rc = ${dns_add_rc}"
        return 0
    fi

    Failure_Reason="'${dns_name}' ${dns_action} failed"
    verbose "CRITICAL  : ${verbose_function}${Failure_Reason}"
    return 1

}

# 1=name, 2=ip or cname, 3=server[:port], 4=key file
function nsupdateRR() {

    local verbose_function
    if [ ${Verbose} -gt 3 ]; then
        printf -v verbose_function "%-18s" "${FUNCNAME}"
    fi

    checkGlobals

    local dns_name="$1"

    if [ ${#dns_name} -eq 0 ]; then
        Failure_Reason="dns name is empty"
        verbose "CRITICAL  : ${verbose_function}${Failure_Reason}"
        return 1
    fi

    if (ipcalc -c -4 "${dns_name}" &> /dev/null); then
        Failure_Reason="dns name can not be an ipv4 address"
        verbose "CRITICAL  : ${verbose_function}${Failure_Reason}"
        return 1
    else
        if (ipcalc -c -6 "${dns_name}" &> /dev/null); then
            Failure_Reason="dns name can not be an ipv6 address"
            verbose "CRITICAL  : ${verbose_function}${Failure_Reason}"
            return 1
        fi
    fi


    local dns_name_dots="${dns_name//[^\.]}"
    dns_name_dots=${#dns_name_dots}

    local dns_data="$2"
    if [ ${#dns_data} -eq 0 ]; then
        if [ "${Dns_Add}" != "0" ]; then
            Failure_Reason="'${dns_name}' dns data is empty"
            verbose "CRITICAL  : ${verbose_function}${Failure_Reason}"
            return 1
        fi
    fi

    local dns_data_ipv4 dns_data_ipv6 dns_type

    dns_data=${dns_data%%/*} # everything before /
    if (ipcalc -c -4 "${dns_data}" &> /dev/null); then
        # it's an ipv4 address
        dns_data_ipv4=0
        dns_data_ipv6=1

        dns_type="A"
    else
        # todo ipv6
        if (ipcalc -c -6 "${dns_data}" &> /dev/null); then
            # it's an ipv6address
            dns_data_ipv4=1
            dns_data_ipv6=0

            dns_type="AAAA"
        else

            # it's not an ip address
            dns_data_ipv4=1
            dns_data_ipv6=1

            dns_type="CNAME"

            # make sure the record it points at is valid; crude
            if ! nslookup ${dns_data} &> /dev/null; then
                Failure_Reason="'${dns_name}' refusing to add CNAME; forward resource record doesn't exist for '${dns_data}'"
                verbose "CRITICAL  : ${verbose_function}${Failure_Reason}"
                return 1
            fi
        fi
    fi

    local dns_server="$3"
    local dns_mname dns_origin dns_zone
    if [ ${#dns_server} -eq 0 ]; then

        if [ ${#Dns_Server} -ne 0 ]; then
            dns_server=${Dns_Server}
        else

            dns_origin=${dns_name}
            if dns_origin=$(nslookupOrigin ${dns_origin}); then
                dns_server=${dns_origin##*,} # everything after ,
                dns_zone=${dns_origin%%,*} # everything before ,
            else
                dns_origin=${dns_data}
                if dns_origin=$(nslookupOrigin ${dns_origin}); then
                    dns_server=${dns_origin##*,} # everything after ,
                    dns_zone=${dns_origin%%,*} # everything before ,
                else
                    verbose "WARNING   : ${verbose_function}'${dns_name}' NOT found for ... '${dns_data}'"
                fi
            fi
        fi

    fi
    unset -v dns_mname dns_origin

    local dns_server_ip
    if [ ${#dns_server} -eq 0 ]; then
        Failure_Reason="'${dns_name}' dns server not found"
        verbose "CRITICAL  : ${verbose_function}${Failure_Reason}"
        return 1
    else
        dns_server_ip=$(getent hosts ${dns_server} 2> /dev/null | awk '{print $1}') # this allows overrides in /etc/hosts

        # todo; revisit this ... when mname is wrong for the domain & getent hosts can't get an ip address
        if [ ${#dns_server_ip} -eq 0 ]; then
            nslookup ${dns_server}
        fi

        if [ ${#dns_server_ip} -eq 0 ]; then
            Failure_Reason="'${dns_name}' dns server ip address not found for '${dns_server}'"
            verbose "CRITICAL  : ${verbose_function}${Failure_Reason}"
            return 1
        else
            verbose "NOTICE    : ${verbose_function}'${dns_name}' dns server ip address found for '${dns_server}' (${dns_server_ip})"
            dns_server=${dns_server_ip} # use the ip address?
        fi
    fi

    local dns_key="$4"

    # done with argument processing, do some more variable validation ...

    local dns_class="IN"
    local dns_ttl=60

    if [ ${dns_name_dots} -eq 0 ]; then
        if [ ${#dns_zone} -eq 0 ]; then
            verbose "ERROR     : ${verbose_function}'${dns_name}' dns name has no domain and dns zone is empty"
        else
            verbose "WARNING   : ${verbose_function}'${dns_name}' dns name has no domain, appending dns zone (${dns_zone})"
            dns_name=${dns_name}.${dns_zone}
            dns_name_dots="${dns_name//[^\.]}"
            dns_name_dots=${#dns_name_dots}
        fi
    fi

    if [ ${#dns_zone} -eq 0 ]; then
        if [ ${dns_name_dots} -eq 0 ]; then
            if [ "${dns_server_ip}" == "127.0.0.1" ] || [ "${dns_server_ip}" == "::1"]; then
                # use default domain, e.g. rpz?
                local localdomain

                for Dns_Zone in ${Dns_Zones[@]}; do
                    if [ "${Dns_Zone}" == "localdomain" ]; then
                        localdomain="localdomain"
                        break
                    fi
                    if [ "${Dns_Zone}" == "rpz" ]; then
                        localdomain="rpz"
                        break
                    fi
                done
                unset -v Dns_Zone

                if [ ${#localdomain} -gt 0 ]; then
                    verbose "WARNING   : ${verbose_function}'${dns_name}' dns zone is empty, using '${localdomain}' response policy zone"
                    dns_name=${dns_name}.${localdomain}
                    dns_name_dots="${dns_name//[^\.]}"
                    dns_name_dots=${#dns_name_dots}
                    dns_zone=${localdomain}
                else
                    Failure_Reason="'${dns_name}' dns zone is empty and dns name has no domain"
                    verbose "CRITICAL  : ${verbose_function}${Failure_Reason}"
                    return 1
                fi
            else
                Failure_Reason="'${dns_name}' dns zone is empty and dns name has no domain"
                verbose "CRITICAL  : ${verbose_function}${Failure_Reason}"
                return 1
            fi
        else
            verbose "WARNING   : ${verbose_function}'${dns_name}' dns zone is empty, using part of dns name (${dns_name#*.})"
            dns_zone=${dns_name#*.}
        fi
    fi

    if [ ${#dns_zone} -eq 0 ]; then
        Failure_Reason="'${dns_name}' dns zone is empty"
        verbose "CRITICAL  : ${verbose_function}${Failure_Reason}"
        return 1
    else
        # here; check that dns_data (names) have a zone
        if [ ${dns_data_ipv4} -ne 0 ] && [ ${dns_data_ipv6} -ne 0 ]; then
            local dns_data_dots="${dns_data//[^\.]}"
            dns_data_dots=${#dns_data_dots}
        fi
    fi

    if [ "${Dns_Delete}" != "0" ]; then
        if nslookup ${dns_name} &> /dev/null; then
            Failure_Reason="refusing to add '${dns_name}'; forward resource record already exists\n"
            verbose "CRITICAL  : ${verbose_function}${Failure_Reason}"
            nslookup ${dns_name}
            return 1
        fi
    fi

    local dns_server_port

    if ! (ipcalc -c -6 "${dns_server}" &> /dev/null); then
        dns_server_port=${dns_server##*:}
        if [ "${dns_server_port}" == "${dns_server}" ]; then
            dns_server_port=53
        else
            dns_server=${dns_server%%:*}
        fi
    fi
    if [ ${#dns_server_port} -eq 0 ]; then
        dns_server_port=53
    fi

    verbose "DEBUG     : ${verbose_function}'${dns_name}' dns_server=${dns_server}:${dns_server_port} dns_zone=${dns_zone} dns_data=${dns_data}"

    local -i dns_add_rc=1
    local -i dns_delete_rc=1

    if [ ${#dns_name} -gt 0 ] && [ ${#dns_zone} -gt 0 ]; then

        local nsupdate_key nsupdate_key_args
        nsupdateKey "${dns_name}" "${dns_server}" "${dns_server_port}" "${dns_key}"
        nsupdate_key=${Nsupdate_Keyfile}
        if [ "${nsupdate_key}" != "none" ] && [ "${nsupdate_key}" != "" ]; then
            nsupdate_key_args="-k ${nsupdate_key}"
        fi
        dns_key=${nsupdate_key}
        unset nsupdate_key

        if [ ${#dns_key} -eq 0 ]; then
            Failure_Reason="'${dns_name}' valid dns key NOT found for '${dns_server}:${dns_server_port}'"
            verbose "CRITICAL  : ${verbose_function}${Failure_Reason}"
            return 1
        fi

        local dns_action
        if [ "${Dns_Add}" == "0" ] && [ "${Dns_Delete}" == "0" ]; then
            dns_action="forward update (delete & add)"
        else
            if [ "${Dns_Add}" == "0" ]; then
                dns_action="forward add"
            else
                if [ "${Dns_Delete}" == "0" ]; then
                    dns_action="forward delete"
                else
                    Failure_Reason="'${dns_name}' dns action is empty"
                    verbose "CRITICAL  : ${verbose_function}${Failure_Reason}"
                    return 1
                fi
            fi
        fi

        printf "\n"
        printf "%-10s = %-32s %20s\n" "dns_action" "${dns_action}" ""
        printf "%-10s = %-32s %20s\n" "dns_name" "${dns_name}" "(${dns_type}) ${dns_data}"
        printf "%-10s = %-32s %20s\n" "dns_zone" "${dns_zone}" "${dns_server}:${dns_server_port}"
        printf "%-10s = %-32s %20s\n" "dns_key" "${dns_key}" ""
        printf "\n"

        if [ "${Dns_Delete}" == "0" ]; then
            (
            #printf "%s\n" "debug"
            printf "server %s %s\n" "${dns_server}" "${dns_server_port}"
            if [ ${#dns_zone} -gt 0 ]; then
                printf "zone %s\n" "${dns_zone}"
            fi
            #printf "del %s %s %s %s %s\n" "${dns_name}" "${dns_ttl}" "${dns_class}" "${dns_type}" "${dns_data}"
            printf "del %s\n" "${dns_name}"
            printf "%s\n" "send"
            #printf "%s\n" "answer"
            ) | nsupdate ${nsupdate_key_args} -t 60 &> /dev/null
            dns_delete_rc=$?
        else
            dns_delete_rc=0
        fi

        if [ "${Dns_Add}" == "0" ] && [ ${dns_delete_rc} -eq 0 ]; then
            (
            #printf "%s\n" "debug"
            printf "server %s %s\n" "${dns_server}" "${dns_server_port}"
            if [ ${#dns_zone} -gt 0 ]; then
                printf "zone %s\n" "${dns_zone}"
            fi
            printf "add %s %s %s %s %s\n" "${dns_name}" "${dns_ttl}" "${dns_class}" "${dns_type}" "${dns_data}"
            printf "%s\n" "send"
            #printf "%s\n" "answer"
            ) | nsupdate ${nsupdate_key_args} -t 60 &> /dev/null
            dns_add_rc=$?
        else
            dns_add_rc=0
        fi

    fi

    if [ ${dns_add_rc} -eq 0 ] && [ ${dns_delete_rc} -eq 0 ]; then
        verbose "DEBUG     : ${verbose_function}dns_delete_rc = ${dns_delete_rc}"
        verbose "DEBUG     : ${verbose_function}dns_add_rc = ${dns_add_rc}"
        return 0
    fi

    Failure_Reason="'${dns_name}' ${dns_action} failed"
    verbose "CRITICAL  : ${verbose_function}${Failure_Reason}"
    return 1
}

function rndc() {

    local verbose_function
    if [ ${Verbose} -gt 3 ]; then
        printf -v verbose_function "%-18s" "${FUNCNAME}"
    fi

    if [ ! -r /etc/rndc.conf ] && [ ! -r /etc/rndc.key ]; then
        # no default keys
        Failure_Reason="rndc has no keys"
        verbose "CRITICAL  : ${verbose_function}${Failure_Reason}"
        return 1
    fi

    local rndc=$(type -P rndc)
    if [ ${#rndc} -eq 0 ] || [ ! -x "${rndc}" ]; then
        Failure_Reason="rndc not executable"
        verbose "CRITICAL  : ${verbose_function}${Failure_Reason}"
        return 1
    fi

    local -i rndc_rc=1

    ${rndc} $@
    rndc_rc=$?

    if [ ${rndc_rc} -ne 0 ]; then
        Failure_Reason="rndc failed with rc=${rndc_rc}"
        verbose "CRITICAL  : ${verbose_function}${Failure_Reason}"
    fi

    return ${rndc_rc}
}

function rndcSync() {

    local verbose_function
    if [ ${Verbose} -gt 3 ]; then
        printf -v verbose_function "%-18s" "${FUNCNAME}"
    fi

    # sync [-clean] zone [class [view]]
    rndc sync -clean

    return $?
}
