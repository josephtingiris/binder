#!/bin/bash

# add/check/delete/update dns records (proof of concept; simplify administration of a common implementation of bind)

# 20190502, jtingiris

shopt -s extglob

#
# Globals
#

PATH=${PATH}:/bin:/usr/bin:/sbin:/usr/sbin

declare -i Verbose_Level
Verbose_Level_Prefix=on
Verbose_Pad_Left=12
Verbose_Pad_Right=30

Dns_Config_Basename="dns.conf"

Default_Data_Class="IN"
Default_Data_Priority=10
Default_Data_Port=443
Default_Data_TTL=3600
Default_Data_Weight=1

# supported actions
Dns_Actions=()
Dns_Actions+=(add)
Dns_Actions+=(check)
Dns_Actions+=(delete)
Dns_Actions+=(lookup)
Dns_Actions+=(update)

# any machine using this script requires these ...
Dns_Dependencies=()
Dns_Dependencies+=(dig)
Dns_Dependencies+=(egrep)
Dns_Dependencies+=(find)
Dns_Dependencies+=(host)
Dns_Dependencies+=(grep)
Dns_Dependencies+=(nsupdate)
Dns_Dependencies+=(sed)

# supported records; see nsupdate -T (on recent versions of nsupdate)
Dns_Records=()
Dns_Records+=(A)
Dns_Records+=(AAAA)
Dns_Records+=(CNAME)
Dns_Records+=(MX)
Dns_Records+=(NS)
Dns_Records+=(PTR)
Dns_Records+=(SRV)
Dns_Records+=(TXT)

declare -g Dns_Status_Trace

Host_Args="-W 2"
Nsupdate_Args="-t 3 -v"

# flags

Dns_All_Flag=1 # false
Dns_Force_Flag=1 # false
Dns_Alert_Mail_Flag=1 # false
Dns_Multiple_Flag=1 # false
Dns_Rndc_Flag=1 # false

#
# Functions
#


# standard output an 'aborting' message and exit with a non-zero return code
function aborting() {
    Dns_Status_Trace="${FUNCNAME}" && dnsStatus

    local abort_message="${@}"
    printf "\naborting, %s\n\n" "${abort_message}"

    if [ "${BASH_SOURCE}" != "${0}" ]; then
        return 2
    else
        exit 2
    fi
}


# output an alert message and send an alert email
function dnsAlert() {
    local alert_arguments=$@

    local alert_message

    if [ ${#Dns_Status_Trace} -gt 0 ]; then
        dnsStatus
    fi

    alert_message="!! ALERT !!:"
    if [ ${#Dns_Status} -gt 0 ]; then
        alert_message+=" ${Dns_Status}"
    fi
    alert_message+=" ${alert_arguments[@]}"

    (>&2 dnsEcho "${alert_message}")

    if [ ${Dns_Alert_Mail_Flag} -eq 0 ]; then
        local alert_mail mailx
        mailx=$(type -P mailx)
        if [ ${#mailx} -gt 0 ] && [ ! -d ${mailx} ] && [ -x ${mailx} ] && [ ${#Dns_Alert_Email} -gt 0 ]; then
            alert_mail="${alert_message}\n\n"
            alert_mail+="exec = '${0} ${Arguments}'\n\n"
            alert_mail+="date = $(date)\n"
            alert_mail+="host = $(hostname)\n"
            alert_mail+="user = $(logname)\n"
            printf "${alert_mail}" | ${mailx} -S "from=DNS <noreply@clacorp.com>" -s "${alert_message}" ${Dns_Alert_Email}
            if [ $? -eq 0 ]; then
                # only send one alert per command line?
                Dns_Alert_Mail_Flag=1
            fi
        fi
    fi
}


# standard output config key value from config file
function dnsBackup() {
    Dns_Status_Trace="${FUNCNAME}" && dnsStatus

    local backup_from="${1}"
    local backup_to="${2}"

    local verbose_level=18

    if [ ! -r "${backup_from}" ]; then
        dnsAlert "backup from '${backup_from}' failed; file NOT readable"
        return 1
    fi

    set -o pipefail

    if [ ${#backup_to} -eq 0 ]; then
        backup_to=${Dns_Dir}/backup$(echo "${backup_from}" 2> /dev/null | sed "s#${Dns_Dir}##g")
        if [ $? -ne 0 ]; then
            dnsAlert "backup from '${backup_from}' failed; sed didn't replace '${Dns_Dir}'"
            aborting
        fi
    fi
    backup_to+="-$(date +%Y%m%d)"

    local backup_count=1
    while [ -a "${backup_to}.${backup_count}" ]; do
        let backup_count=${backup_count}+1
    done

    if [ -a "${backup_to}.$((backup_count-1))" ] && [ ! -d "${backup_to}.$((backup_count-1))" ]; then
        diff -q "${backup_from}" "${backup_to}.$((backup_count-1))" &> /dev/null
        if [ $? -eq 0 ]; then
            # no need to backup; files are identical
            return 2
        fi
    fi

    backup_to+=".${backup_count}"

    dnsVerbose "backup_from=${backup_from}" ${verbose_level}
    dnsVerbose "backup_to=${backup_to}" ${verbose_level}

    local backup_dir
    if [ ! -d "${backup_from}" ]; then
        backup_dir="$(dirname "${backup_to}")"
    else
        backup_dir="${backup_to}"
    fi

    if [ ! -d "${backup_dir}" ]; then
        mkdir -p "${backup_dir}"
        if [ $? -ne 0 ]; then
            aborting "failed to mkdir -p '${backup_dir}'"
        fi
    fi

    if [ ! -w "${backup_dir}" ]; then
        aborting "'${backup_dir}' directory NOT writable"
    fi

    dnsVerbose "backup_dir=${backup_dir}" ${verbose_level}

    if [ -d "${backup_from}" ]; then
        cp -rp "${backup_from}/" "${backup_to}"
        if [ $? -eq 0 ]; then
            return 0
        else
            aborting "cp -rp '${backup_from}/' '${backup_to}/' failed"
        fi
    else
        cp -p "${backup_from}" "${backup_to}"
        if [ $? -eq 0 ]; then
            return 0
        else
            aborting "cp -p '${backup_from}' '${backup_to}/' failed"
        fi
    fi

    aborting "dead code; bug"
}


# standard output config key value from config file
function dnsConfig() {
    Dns_Status_Trace="${FUNCNAME}" && dnsStatus

    local dns_config_key="${1}"
    local dns_config_file="${2}"

    local verbose_level=18

    if [ ${#dns_config_key} -eq 0 ]; then
        return 1
    fi

    if [ ${#dns_config_file} -eq 0 ]; then
        dns_config_file="${Dns_Config_File}"
    fi

    if [ ${#dns_config_file} -eq 0 ]; then
        dnsAlert "configuration file missing; value is empty"
        aborting
    else
        if [ ! -r "${dns_config_file}" ]; then
            dnsAlert "configuration file missing; '${dns_config_file}' file NOT readable"
            aborting
        fi
    fi

    set -o pipefail

    # strip spaces!
    sed -e '/[[:space:]]/s///g' "${dns_config_file}" 2> /dev/null | egrep -e "^${dns_config_key}=" | head -1 | awk -F\# '{print $1}' | sed -nEe 's#.*=(.*).*#\1#p' 2> /dev/null

    # return pipefail result code
    return $?

}


# return true or false if the name & data is valid for a given record (type)
function dnsDataValid() {
    Dns_Status_Trace="${FUNCNAME}" && dnsStatus

    local dns_record="${1^^}"
    local dns_name="${2,,}"
    local dns_data="${3}"

    local verbose_level=3

    if [ ${#dns_record} -eq 0 ]; then
        return 1
    fi

    local dns_data_valid=0 # err to the side of caution?

    # note: dnsZoneArpa validates A, AAAA, & PTR

    # todo: add other record type data validation

    # https://en.wikipedia.org/wiki/List_of_DNS_record_types

    if [ ${dns_data_valid} -eq 0 ] && [ "${dns_record}" == "CNAME" ]; then
        if [ "${dns_data}" != "${dns_data//+([[:space:]])/}" ]; then
            dns_data_valid=1
        else
            if (ipcalc -c "${dns_data}" &> /dev/null); then
                dns_data_valid=1
            fi
        fi
    fi

    return ${dns_data_valid}
}


# standard output with consistency
function dnsEcho() {
    local echo_message="${@}"

    echo_message=${echo_message//+([[:space:]])/ }

    local character counter pad_colon pad_equal padded padding unpadded

    pad_colon=0
    pad_equal=0
    for (( counter=0; counter<${#echo_message}; counter++ )); do
        character="${echo_message:$counter:1}"
        let padding=0
        if [ "${character}" == ":" ] && [ ${counter} -lt 50 ]; then
            unpadded="${padded}"
            let pad_colon=${pad_colon}+1
            let padding=${Verbose_Pad_Left}*${pad_colon}
            printf -v padded "%-${padding}b : " "${unpadded}"
        else
            if [ "${character}" == "=" ] && [ ${counter} -lt 132 ]; then
                unpadded="${padded}"
                let pad_equal=${pad_equal}+1
                let padding=${Verbose_Pad_Right}*${pad_equal}
                printf -v padded "%-${padding}b = " "${unpadded}"
            else
                padded+="${character}"
            fi
        fi
        unset -v padding upadded
    done

    echo_message="${padded}"
    echo_message=${echo_message//:+([[:space:]])/: }
    echo_message=${echo_message//=+([[:space:]])/= }

    unset -v  character counter padded padding unpadded

    if [ "${Dns_Date}" == "0" ]; then
        echo_message="[$(date +%F\ %R:%S)] ${echo_message}"
    fi

    # enhanced messages
    if [ ${#TPUT_BOLD} -gt 0 ] && [ ${#TPUT_SGR0} -gt 0 ]; then
        if [ ${#TPUT_SETAF_1} -gt 0 ]; then
            # red
            if [[ "${echo_message^^}" == *"ALERT"* ]]; then
                echo_message="${TPUT_BOLD}${TPUT_SETAF_1}${echo_message}${TPUT_SGR0}"
            else
                if [ ${#TPUT_SETAF_3} -gt 0 ]; then
                    # yellow
                    if [[ "${echo_message^^}" == *"WARNING"* ]]; then
                        echo_message="${TPUT_BOLD}${TPUT_SETAF_3}${echo_message}${TPUT_SGR0}"
                    fi
                fi
            fi
        fi
    fi

    printf "%b\n" "${echo_message}"
}


# standard output a fully qualified domain name
function dnsFQDN() {
    Dns_Status_Trace="${FUNCNAME}" && dnsStatus

    local dns_name="${1}"
    local dns_zone_arpa="${2}"
    local dns_zone="${3}"
    local dns_config_file="${4}"
    local dns_view="${5}"

    local verbose_level=17

    if [ ${#dns_name} -eq 0 ]; then
        dnsAlert "dns_name is empty"
        return 1
    fi

    dnsVerbose "dns_name=${dns_name}" ${verbose_level}
    dnsVerbose "dns_zone_arpa=${dns_zone_arpa}" ${verbose_level}
    dnsVerbose "dns_zone=${dns_zone}" ${verbose_level}
    dnsVerbose "dns_config_file=${dns_config_file}" ${verbose_level}
    dnsVerbose "dns_view=${dns_view}" ${verbose_level}

    local dns_fqdn dns_name_dots dns_zone_default

    dns_name_dots="${dns_name//[^\.]}"
    dns_name_dots=${#dns_name_dots}

    # compress dots & recount
    if [ ${dns_name_dots} -gt 0 ]; then
        dns_name=$(echo "${dns_name}"| sed -e 's#\.\.*#\.#g' -e 's#^\.##g' -e 's#\.$##g');
        dns_name_dots="${dns_name//[^\.]}"
        dns_name_dots=${#dns_name_dots}
    fi

    # ensure zone is stripped from name
    if [ ${#dns_zone} -gt 0 ]; then
        dns_name=$(echo "${dns_name}" | sed -e "s#${dns_zone}##g")
        dns_name+=".${dns_zone}"
        dns_name=${dns_name//../.}
        dns_name_dots="${dns_name//[^\.]}"
        dns_name_dots=${#dns_name_dots}
    fi

    if [ ${dns_name_dots} -gt 0 ]; then
        # the name has dots; return the name as the fqdn
        dns_fqdn="${dns_name}"
    else
        # the name doesn't have dots; figure out what the zone is ...

        if [ ${#dns_zone} -gt 0 ]; then
            dns_fqdn=$(echo "${dns_name}.${dns_zone}"| sed -e 's#\.\.*#\.#g' -e 's#^\.##g' -e 's#\.$##g');
        else
            if [ ${#dns_zone_arpa} -gt 0 ]; then
                dnsVerbose "dns_config_file=${dns_config_file}" ${verbose_level}
                dnsVerbose "dns_view=${dns_view}" ${verbose_level}

                local dns_zone_config
                dns_zone_config=$(dnsZoneConfig "${dns_zone_arpa}" "${dns_config_file}" "${dns_view}")

                dnsVerbose "dns_zone_config=${dns_zone_config}" ${verbose_level}

                dns_zone=$(echo "${dns_zone_config}" | awk -F, '{print $1}')

                # remove placeholder
                if [ "${dns_zone}" == "*" ] || [ "${dns_zone,,}" == "default" ]; then
                    dns_zone=""
                fi

                dnsVerbose "dns_zone=${dns_zone}" ${verbose_level}
            fi

            if [ ${#dns_zone} -gt 0 ]; then
                dns_fqdn="${dns_name}.${dns_zone}"
            else
                dns_zone_default=$(dnsConfig Dns_Zone_Default | sed -e 's#\.\.*#\.#g' -e 's#^\.##g' -e 's#\.$##g');
                if [ ${#dns_zone_default} -eq 0 ]; then
                    if [ ${#dns_zone_default} -eq 0 ]; then
                        dnsAlert "dns_zone_default is NOT set, using localdomain"
                        dns_zone_default=localdomain
                    fi
                fi

                if [ ${#dns_zone_default} -eq 0 ]; then
                    dns_fqdn="${dns_name}"
                else
                    dns_fqdn="${dns_name}.${dns_zone_default}"
                fi
            fi
        fi
    fi

    if [ ${#dns_fqdn} -gt 0 ]; then
        printf "${dns_fqdn}" | sed -e '/\.*$/s///g'
        return 0
    else
        return 1
    fi
}


# return true if dns record data matches dig record data
function dnsLookup() {
    Dns_Status_Trace="${FUNCNAME}" && dnsStatus

    local -l dns_lookup_action="${1:0:5}"
    local -u dns_record="${2}"
    local -l dns_fqdn="${3}"
    local -l dns_data="${4}"
    local -l dns_server="${5}"
    local -i dns_server_port="${6}"
    local dns_zone_key="${7}"
    local dns_zone_keyfile="${8}"

    local verbose_level

    if [ "${dns_record}" == "A" ] || [ "${dns_record}" == "AAAA" ]; then
        verbose_level=21
    else
        if [ "${dns_record}" == "CNAME" ]; then
            verbose_level=22
        else
            if [ "${dns_record}" == "IP" ]; then
                verbose_level=24
            else
                if [ "${dns_record}" == "MX" ]; then
                    verbose_level=24
                else
                    if [ "${dns_record}" == "PTR" ]; then
                        verbose_level=24
                    else
                        if [ "${dns_record}" == "SOA" ]; then
                            verbose_level=24
                        else
                            if [ "${dns_record}" == "SRV" ]; then
                                verbose_level=24
                            else
                                if [ "${dns_record}" == "TXT" ]; then
                                    verbose_level=26
                                else
                                    if [ "${Dns_Action}" == "lookup" ]; then
                                        verbose_level=28
                                    else
                                        verbose_level=32
                                    fi
                                fi
                            fi
                        fi
                    fi
                fi
            fi
        fi
    fi

    if [ ${#dns_lookup_action} -eq 0 ]; then
        dnsAlert "dns_lookup_action is empty"
        return 1
    fi

    if [ "${dns_lookup_action}" != "exact" ] && [ "${dns_lookup_action}" != "exist" ] && [ "${dns_lookup_action}" != "match" ] && [ "${dns_lookup_action}" != "value" ]; then
        dnsAlert "dns_lookup_action '${dns_lookup_action}' is invalid"
        return 1
    fi

    if [ ${#dns_record} -eq 0 ]; then
        dnsAlert "dns_record is empty"
        return 1
    fi

    if [ ${#dns_fqdn} -eq 0 ]; then
        dnsAlert "dns_fqdn is empty"
        return 1
    fi

    if [ ${#dns_data} -eq 0 ]; then
        dnsAlert "dns_data is empty"
        return 1
    fi

    if [ ${#dns_server} -eq 0 ]; then
        dnsVerbose "dns_server is empty (${dns_fqdn})" ${verbose_level}
    fi

    if [[ ! ${dns_server_port} =~ ^[0-9]+$ ]]; then
        dns_server_port=""
    fi

    local dig_args dns_lookup_rc dns_lookup_result dns_lookup_results

    if [ "${dns_record}" == "IP" ]; then
        if (ipcalc -c "${dns_fqdn}" &> /dev/null); then
            dns_lookup_results=(${dns_fqdn})
        fi
    fi

    dnsVerbose "dns_lookup_action=${dns_lookup_action}" ${verbose_level}

    dnsVerbose "dns_record=${dns_record}" ${verbose_level}

    dnsVerbose "dns_fqdn=${dns_fqdn}" ${verbose_level}

    dnsVerbose "dns_data=${dns_data}" ${verbose_level}

    dnsVerbose "dns_server=${dns_server} ${dns_server_port}" ${verbose_level}

    dnsVerbose "dns_zone_key=${dns_zone_key}" ${verbose_level}

    dnsVerbose "dns_zone_keyfile=${dns_zone_keyfile}" ${verbose_level}

    if [ ${#dns_lookup_results} -eq 0 ]; then
        dig_args=""
        if [ ${#dns_server} -gt 0 ]; then
            dig_args+="@${dns_server}"
        fi

        if [ "${Dns_Action}" == "lookup" ]; then
            if [ "${dns_record}" == "A" ] || [ "${dns_record}" == "AAAA" ] || [ "${dns_record}" == "CNAME" ] || [ "${dns_record}" == "IP" ] || [ "${dns_record}" == "SOA" ]; then
                dig_args+=" +short"
            fi
        else
            dig_args+=" +short"
        fi

        dig_args+=" +noauthority"

        #dig_args+=" +tcp"

        dig_args+=" +retry=1" # retry
        if [ "${dns_record}" == "IP" ]; then
            dig_args+=" +search"
        fi
        dig_args+=" +time=1" # timeout

        if [ "${dns_record}" == "IP" ]; then
            dig_args+=" +search"
        else
            dig_args+=" -t ${dns_record}"
        fi

        if [ -r "${dns_zone_keyfile}" ]; then
            dig_args+=" -k ${dns_zone_keyfile}"
        fi

        dig_args+=" -q ${dns_fqdn}"

        if [ ${#Dns_Record_IP_Family} -gt 0 ]; then
            if [ "${Dns_Record_IP_Family}" == "4" ] || [ "${Dns_Record_IP_Family}" == "6" ]; then
                dig_args+=" -${Dns_Record_IP_Family}"
                if [ "${dns_record}" == "IP" ]; then
                    if [ "${Dns_Record_IP_Family}" == "4" ]; then
                        dig_args+=" -t A"
                    else
                        if [ "${Dns_Record_IP_Family}" == "6" ]; then
                            dig_args+=" -t AAAA"
                        fi
                    fi
                fi
            fi
        else
            if [ "${dns_record}" == "IP" ]; then
                dig_args+=" -t ANY"
            fi
        fi

        if [ ${#dns_server_port} -gt 0 ] && [ "${dns_server_port}" != "0" ]; then
            dig_args+=" -p ${dns_server_port}"
        fi

        dnsVerbose "dig_args=${dig_args}" ${verbose_level}
        dns_lookup_results=($(dig ${dig_args} 2> /dev/null | egrep -ve "^;|TSIG" | sed -e 's#[[:space:]]#++SPACE++#g'))

        # dig +short CNAME, & possibly other records, return values for SOA queries that are not really a valid SOA; workaround ...
        if [ "${dns_record}" == "SOA" ]; then
            if [[ ! "${dns_lookup_results}" =~ "++SPACE++" ]]; then
                dnsVerbose "dns_lookup_results=${dns_lookup_results} [INVALID SOA]" ${verbose_level}
                dns_lookup_results=""
            fi
        fi

    fi

    local exact_rc

    if [ ${#dns_lookup_results} -eq 0 ]; then
        dns_lookup_rc=1
        exact_rc=1
    else
        dns_lookup_rc=0
        exact_rc=0
    fi

    dnsVerbose "dns_fqdn=${dns_fqdn} ${dns_record}=${dns_lookup_results[@]} (${dns_lookup_rc})" ${verbose_level}

    if [ "${dns_lookup_action}" == "exist" ]; then
        dnsVerbose "dns_lookup_rc=${dns_lookup_rc} ${dns_fqdn} ${dns_record}" ${verbose_level}
        return ${dns_lookup_rc}
    fi

    if [ "${dns_lookup_action}" == "exact" ] || [ "${dns_lookup_action}" == "match" ]; then
        local match_rc=1 # false
        if [ ${#dns_lookup_results} -gt 0 ]; then
            for dns_lookup_result in "${dns_lookup_results[@]}"; do
                dns_lookup_result=${dns_lookup_result//++SPACE++/ }
                if [ "${dns_record}" == "MX" ] || [ "${dns_record}" == "SRV" ]; then
                    dns_lookup_result=${dns_lookup_result##* }
                fi
                if [ "${dns_lookup_result:${#dns_lookup_result}-1:1}" == "." ]; then
                    dns_lookup_result=${dns_lookup_result::-1}
                fi
                if [ "${dns_lookup_result}" == "${dns_data}" ] || [ "${dns_lookup_result//\"/}" == "${dns_data}" ]; then
                    dnsVerbose "dns_lookup_result=${dns_lookup_result} (${dns_data}) [${exact_rc}] [${dns_lookup_action} match]" $((${verbose_level}+1))

                    match_rc=0
                    if [ "${dns_lookup_action}" == "match" ]; then
                        break
                    fi
                else
                    dnsVerbose "dns_lookup_result=${dns_lookup_result} (${dns_data}) [${exact_rc}] [${dns_lookup_action} mismatch]" $((${verbose_level}+1))
                    let exact_rc=${exact_rc}+1
                fi
            done
        fi

        dnsVerbose "${dns_record} ${dns_fqdn}=${dns_lookup_result}" ${verbose_level}

        if [ "${dns_lookup_action}" == "exact" ]; then
            dnsVerbose "exact_rc=${exact_rc}" ${verbose_level}
            return ${exact_rc}
        else
            dnsVerbose "match_rc=${match_rc}" ${verbose_level}
            return ${match_rc}
        fi
    fi

    if [ "${dns_lookup_action}" == "value" ]; then
        local value_rc=1 # false
        if [ ${#dns_lookup_results} -gt 0 ]; then
            for dns_lookup_result in "${dns_lookup_results[@]}"; do
                dns_lookup_result=${dns_lookup_result//++SPACE++/ }
                if [ "${dns_lookup_result:${#dns_lookup_result}-1:1}" == "." ]; then
                    dns_lookup_result=${dns_lookup_result::-1}
                fi
                dnsVerbose "${dns_record} ${dns_lookup_action} dns_lookup_result=${dns_lookup_result}" ${verbose_level}
                if [ "${Dns_Action}" == "lookup" ]; then
                    echo ${dns_lookup_result}
                else
                    if [ "${dns_record}" == "A" ]; then
                        if (ipcalc -4 -c ${dns_lookup_result} 2> /dev/null); then
                            echo ${dns_lookup_result}
                        else
                            value_rc=1
                            break
                        fi
                    else
                        if [ "${dns_record}" == "AAAA" ]; then
                            if (ipcalc -6 -c ${dns_lookup_result} 2> /dev/null); then
                                echo ${dns_lookup_result}
                            else
                                value_rc=1
                                break
                            fi
                        else
                            if [ "${dns_record}" == "CNAME" ]; then
                                if ! (ipcalc -c ${dns_lookup_result} 2> /dev/null); then
                                    echo ${dns_lookup_result}
                                fi
                            else
                                if [ "${dns_record}" == "IP" ]; then
                                    if (ipcalc -c ${dns_lookup_result} 2> /dev/null); then
                                        echo ${dns_lookup_result}
                                    fi
                                else
                                    echo ${dns_lookup_result}
                                fi
                            fi
                        fi
                    fi
                fi
                value_rc=0
            done
        fi
        return ${value_rc}
    fi

    return 1
}


# set Dns_Status global (used for clean, consistent output)
function dnsStatus {

    if [ ${#Dns_Status_Trace} -eq 0 ]; then
        Dns_Status_Trace="${FUNCNAME}"
    fi

    local -i verbose_level=${Verbose_Level}
    Dns_Status=""

    if [ ${#Dns_Action_RR} -gt 0 ]; then
        Dns_Status+=" [${Dns_Action_RR^^}]:"
    else
        if [ ${#Dns_Action} -gt 0 ]; then
            Dns_Status+=" [${Dns_Action^^}]:"
        fi
    fi

    if [ ${#Dns_Lookup_FQDN_RR} -gt 0 ]; then
        Dns_Status+=" ${Dns_Lookup_FQDN_RR}"
    else
        if [ ${#Dns_FQDN_RR} -gt 0 ]; then
            Dns_Status+=" ${Dns_FQDN_RR}"
        else
            if [ ${#Dns_FQDN} -gt 0 ]; then
                Dns_Status+=" ${Dns_FQDN}"
            else
                if [ ${#Dns_Lookup_Data_RR} -gt 0 ]; then
                    Dns_Status+=" ${Dns_Lookup_Data_RR}"
                else
                    if [ ${#Dns_Data_RR} -gt 0 ]; then
                        Dns_Status+=" ${Dns_Data_RR}"
                    else
                        if [ ${#Dns_Data} -gt 0 ]; then
                            Dns_Status+=" ${Dns_Data}"
                        else
                            if [ ${#Dns_Zone_Reference_RR} -gt 0 ]; then
                                Dns_Status+=" ${Dns_Zone_Reference_RR}"
                            fi
                        fi
                    fi
                fi
            fi
        fi
    fi

    if [ ${#Dns_RR} -gt 0 ]; then
        Dns_Status+=" ${Dns_RR}"
    else
        if [ ${#Dns_Record} -gt 0 ]; then
            Dns_Status+=" ${Dns_Record}"
        fi
    fi

    if [ ${verbose_level} -gt 0 ]; then
        if [ ${#Dns_Status} -gt 0 ]; then
            Dns_Status+=", "
        fi

        if [ ${#Dns_Server_IP_RR} -gt 0 ]; then
            Dns_Status+="server ${Dns_Server_IP_RR}"
        else
            if [ ${#Dns_Server_IP} -gt 0 ]; then
                Dns_Status+="server ${Dns_Server_IP}"
            else
                if [ ${#Dns_Server_RR} -gt 0 ]; then
                    Dns_Status+="server ${Dns_Server_RR}"
                else
                    if [ ${#Dns_Server} -gt 0 ]; then
                        Dns_Status+="server ${Dns_Server}"
                    fi
                fi
            fi
        fi
    fi

    if [ ${#Dns_View_RR} -gt 0 ]; then
        Dns_Status+=", view ${Dns_View_RR}"
    else
        if [ ${#Dns_View} -gt 0 ]; then
            Dns_Status+=", view ${Dns_View}"
        fi
    fi

    if [ ${verbose_level} -gt 0 ]; then
        if [ ${#Dns_Zone_Key_RR} -gt 0 ]; then
            Dns_Status+=", key ${Dns_Zone_Key_RR}"
        else
            if [ ${#Dns_Zone_Key} -gt 0 ]; then
                Dns_Status+=", key ${Dns_Zone_Key}"
            fi
        fi
    fi

    Dns_Status=${Dns_Status%,*}

    if [ ${#Dns_Status_Trace} -gt 0 ] && [ ${verbose_level} -gt 0 ]; then
        if [ ${#Dns_Status} -gt 0 ]; then
            Dns_Status+="="
        fi
        Dns_Status+="[${Dns_Status_Trace}]"
    fi

    #if [ ${#Dns_Status} -gt 0 ]; then
    #Dns_Status+="="
    #fi

}

# action dns resource record
function dnsUpdate() {
    Dns_Status_Trace="${FUNCNAME}" && dnsStatus

    local -l dns_action="${1}"
    local -u dns_record="${2}"
    local -l dns_fqdn="${3}"
    local -l dns_data="${4}"
    local -u dns_data_class="${5}"
    local -i dns_data_port="${6}"
    local -i dns_data_priority="${7}"
    local -i dns_data_ttl="${8}"
    local -i dns_data_weight="${9}"
    local -l dns_server="${10}"
    local -i dns_server_port="${11}"
    local -l dns_zone="${12}"
    local -l dns_zone_arpa="${13}"
    local -l dns_zone_soa="${14}"
    local dns_zone_key="${15}"
    local dns_zone_keyfile="${16}"

    local verbose_level=12

    if [ ${#dns_action} -eq 0 ]; then
        dnsAlert "dns_action is empty"
        return 1
    fi

    dnsVerbose "dns_action=${dns_action}" ${verbose_level}

    if [ ${#dns_record} -eq 0 ]; then
        dnsAlert "dns_record is empty"
        return 1
    fi

    dnsVerbose "dns_record=${dns_record}" ${verbose_level}

    if [ ${#dns_fqdn} -eq 0 ]; then
        dnsAlert "dns_fqdn is empty"
        return 1
    fi

    dnsVerbose "dns_fqdn=${dns_fqdn}" ${verbose_level}

    if [ ${#dns_data} -eq 0 ]; then
        if [ "${dns_action}" != "delete" ]; then
            dnsAlert "dns_data is empty"
            return 1
        fi
    fi

    dnsVerbose "dns_data=${dns_data}" ${verbose_level}

    if [ "${dns_data_class}" != "IN" ]; then
        dnsAlert "dns_data_class is NOT 'IN'"
        return 1
    fi

    dnsVerbose "dns_data_class=${dns_data_class}" ${verbose_level}

    if [[ ! ${dns_data_port} =~ ^[0-9]+$ ]]; then
        dnsAlert "dns_data_port is NOT an integer"
        return 1
    fi

    dnsVerbose "dns_data_port=${dns_data_port}" ${verbose_level}

    if [[ ! ${dns_data_priority} =~ ^[0-9]+$ ]]; then
        dnsAlert "dns_data_priority is NOT an integer"
        return 1
    fi

    dnsVerbose "dns_data_priority=${dns_data_priority}" ${verbose_level}

    if [[ ! ${dns_data_ttl} =~ ^[0-9]+$ ]]; then
        dnsAlert "dns_data_ttl is NOT an integer"
        return 1
    else
        if [ ${dns_data_ttl} -lt 10 ]; then
            dnsAlert "dns_data_ttl can NOT be less than 10 seconds" ${verbose_level}
            return 1
        fi
    fi

    dnsVerbose "dns_data_weight=${dns_data_weight}" ${verbose_level}

    if [[ ! ${dns_data_weight} =~ ^[0-9]+$ ]]; then
        dnsAlert "dns_data_weight is NOT an integer"
        return 1
    fi

    dnsVerbose "dns_data_weight=${dns_data_weight}" ${verbose_level}

    if [ ${#dns_server} -eq 0 ]; then
        dnsAlert "dns_server is empty"
        return 1
    fi

    if [ ${#dns_server_port} -eq 0 ] || [[ ! ${dns_server_port} =~ ^[0-9]+$ ]]; then
        dnsAlert "dns_server_port is empty"
        return 1
    fi

    dnsVerbose "dns_server=${dns_server} (${dns_server_port})" ${verbose_level}

    if [ ${#dns_zone} -eq 0 ]; then
        dnsAlert "dns_zone is empty"
        return 1
    fi

    dnsVerbose "dns_zone=${dns_zone}" ${verbose_level}

    if [ "${dns_record}" == "PTR" ]; then
        if [ ${#dns_zone_arpa} -eq 0 ]; then
            dnsAlert "dns_zone_arpa is empty"
            return 1
        fi
        dnsVerbose "dns_zone_arpa=${dns_zone_arpa}" ${verbose_level}
    fi

    dnsVerbose "dns_zone_soa=${dns_zone_soa}" ${verbose_level}

    dnsVerbose "dns_zone_key=${dns_zone_key}" ${verbose_level}

    dnsVerbose "dns_zone_keyfile=${dns_zone_keyfile}" ${verbose_level}

    # only change actions can proceed ...

    if [ "${dns_action}" != "add" ] && [ "${dns_action}" != "delete" ] && [ "${dns_action}" != "update" ]; then
        return 1
    fi

    # TXT record data can be free formed strings with spaces; if there are spaces and no double quotes then add them
    if [ "${dns_record}" == "TXT" ]; then
        if [ "${dns_data}" != "${dns_data//+([[:space:]])/}" ]; then
            dns_data=${dns_data##+([[:space:]])} # remove leading white spaces
            dns_data=${dns_data%%+([[:space:]])} # remove trailing white spaces
            if [ "${dns_data:0:1}" != "\"" ]; then
                dns_data="\"${dns_data}"
            fi
            if [ "${dns_data:${#dns_data}-1:1}" != "\"" ]; then
                dns_data+="\""
            fi
        fi
    fi

    local dns_add dns_delete

    if [ "${dns_action}" == "update" ]; then
        dns_add=0
        dns_delete=0
    else
        if [ "${dns_action}" == "add" ]; then
            dns_add=0
        else
            dns_add=1
        fi
        if [ "${dns_action}" == "delete" ]; then
            dns_delete=0
        else
            dns_delete=1
        fi
    fi

    local nsupdate_key_args
    if [ ${#dns_zone_keyfile} -gt 0 ] && [ -r "${dns_zone_keyfile}" ]; then
        nsupdate_key_args="-k ${dns_zone_keyfile}"
    fi
    dnsVerbose "nsupdate_key_args=${nsupdate_key_args}" ${verbose_level}

    nsupdate_script="server ${dns_server} ${dns_server_port}\n"
    nsupdate_script+="zone ${dns_zone}.\n"
    if [ "${dns_zone_keyfile}" == "gsstsig" ]; then
        nsupdate_script+="gsstsig\n"
    fi
    if [ "${dns_zone_keyfile}" == "oldgsstsig" ]; then
        nsupdate_script+="oldgsstsig\n"
    fi

    if [ ${dns_delete} -eq 0 ]; then

        if [ "${dns_record}" == "A" ] || [ "${dns_record}" == "AAAA" ]; then
            nsupdate_script+="; ${dns_record} delete\n";
            nsupdate_script+="update delete ${dns_fqdn}. ${dns_record}"
            if [ ${Dns_Force_Flag} -ne 0 ]; then
                if [ "${Dns_Action}" != "update" ]; then
                    nsupdate_script+=" ${dns_data}"
                fi
            fi
            nsupdate_script+="\n"
            #if [ ${Dns_Force_Flag} -eq 0 ]; then
            if [ ${Dns_Force_Flag} -eq 0 ] && [ "${dns_fqdn}" != "${dns_data}" ]; then
                # not quite sure if this is the 'right' thing to do here, either ...
                # also delete CNAME
                nsupdate_script+="\n"
                nsupdate_script+="update delete ${dns_fqdn}. CNAME\n"
            fi
        else
            if [ "${dns_record}" == "CNAME" ]; then
                nsupdate_script+="; CNAME delete\n";
                nsupdate_script+="update delete ${dns_fqdn}. ${dns_record}"
                if [ ${#dns_data} -gt 0 ] && [ "${dns_data}" != "${dns_fqdn}" ]; then
                    if [ ${Dns_Force_Flag} -ne 0 ]; then
                        if [ "${Dns_Action}" != "update" ]; then
                            nsupdate_script+=" ${dns_data}."
                        fi
                    fi
                fi
                nsupdate_script+="\n"
                if [ ${Dns_Force_Flag} -eq 0 ] && [ "${dns_fqdn}" != "${dns_data}" ]; then
                    # not quite sure if this is the 'right' thing to do here ...
                    # also delete A & AAAA
                    nsupdate_script+="\n"
                    nsupdate_script+="update delete ${dns_fqdn}. A\n"
                    nsupdate_script+="\n"
                    nsupdate_script+="update delete ${dns_fqdn}. AAAA\n"
                fi
            else
                if [ "${dns_record}" == "MX" ]; then
                    nsupdate_script+="; MX delete\n";
                    local mx_record mx_records mx_record_data mx_record_priority
                    mx_records=($(dnsLookup value "${dns_record}" "${dns_fqdn}" "${dns_data}" "${dns_server}" "${dns_server_port}" "${dns_zone_key}" "${dns_zone_keyfile}" 2> /dev/null | grep "^[0-9].*[[:space:]]${dns_data}$" | sed -e 's#[[:space:]]#++SPACE++#g'))
                    for mx_record in "${mx_records[@]}"; do
                        if [[ "${mx_record}" == *"++SPACE++"* ]]; then
                            mx_record=${mx_record//++SPACE++/ }
                            mx_record_data=${mx_record#* }
                            mx_record_priority=${mx_record% *}
                            if [[ ${mx_record_priority} =~ ^[0-9]+$ ]]; then
                                if [ "${mx_record_data}" == "${dns_data}" ]; then
                                    dnsVerbose "mx_record=${mx_record} (${mx_record_priority})" 3
                                    nsupdate_script+="update delete ${dns_fqdn}. ${dns_record}"
                                    nsupdate_script+=" ${mx_record_priority}"
                                    nsupdate_script+=" ${dns_data}."
                                    nsupdate_script+="\n"
                                    nsupdate_script+="\n"
                                else
                                    dnsAlert "MX record '${mx_record}'; dns data '${dns_data}' does not match"
                                fi
                            else
                                dnsAlert "MX record '${mx_record}'; priority is not an integer"
                            fi
                        fi
                    done

                else
                    if [ "${dns_record}" == "NS" ]; then
                        nsupdate_script+="; NS delete\n";
                        nsupdate_script+="update delete ${dns_fqdn}. ${dns_record} ${dns_data}.\n"
                    else
                        if [ "${dns_record}" == "PTR" ]; then
                            nsupdate_script+="; PTR delete\n";
                            nsupdate_script+="update delete ${dns_fqdn}. ${dns_record}\n"
                        else
                            if [ "${dns_record}" == "SRV" ]; then
                                nsupdate_script+="; SRV delete\n";
                                nsupdate_script+="update delete ${dns_fqdn}. ${dns_record}\n"
                            else
                                if [ "${dns_record}" == "TXT" ]; then
                                    nsupdate_script+="; TXT delete\n";
                                    nsupdate_script+="update delete ${dns_fqdn}. ${dns_record}"
                                    if [ ${#dns_data} -gt 0 ] && [ "${dns_data}" != "${dns_fqdn}" ]; then
                                        nsupdate_script+=" "
                                        #nsupdate_script+="\""
                                        nsupdate_script+="${dns_data}"
                                        #nsupdate_script+="\""
                                    fi
                                    nsupdate_script+="\n"
                                else
                                    nsupdate_script+="; OTHER (${dns_record}) delete\n";
                                    nsupdate_script+="update delete ${dns_fqdn}. ${dns_record} ${dns_data}\n"
                                fi
                            fi
                        fi
                    fi
                fi
            fi
        fi

    fi


    if [ ${dns_delete} -eq 0 ] && [ ${dns_add} -eq 0 ]; then
        nsupdate_script+="\n"
    fi

    if [ ${dns_add} -eq 0 ]; then


        if [ "${dns_record}" == "A" ] || [ "${dns_record}" == "AAAA" ]; then
            nsupdate_script+="; ${dns_record} add\n";
            if [ ${Dns_Multiple_Flag} -ne 0 ]; then
                nsupdate_script+="prereq nxrrset ${dns_fqdn}. ${dns_record}\n"
            fi
            nsupdate_script+="prereq nxrrset ${dns_fqdn}. CNAME\n"
            nsupdate_script+="update add ${dns_fqdn}. ${dns_data_ttl} ${dns_data_class} ${dns_record} ${dns_data}\n"
        else
            if [ "${dns_record}" == "CNAME" ]; then
                nsupdate_script+="; CNAME add\n";
                nsupdate_script+="prereq nxdomain ${dns_fqdn}.\n"
                nsupdate_script+="update add ${dns_fqdn}. ${dns_data_ttl} ${dns_data_class} ${dns_record} ${dns_data}.\n"
            else
                if [ "${dns_record}" == "MX" ]; then
                    nsupdate_script+="; MX add\n";
                    nsupdate_script+="update add ${dns_fqdn}. ${dns_data_ttl} ${dns_data_class} ${dns_record} ${dns_data_priority} ${dns_data}.\n"
                else
                    if [ "${dns_record}" == "PTR" ]; then
                        nsupdate_script+="; PTR add\n";
                        nsupdate_script+="update add ${dns_fqdn}. ${dns_data_ttl} ${dns_data_class} ${dns_record} ${dns_data}.\n"
                    else
                        if [ "${dns_record}" == "SRV" ]; then
                            nsupdate_script+="; SRV add\n";
                            nsupdate_script+="update add ${dns_fqdn}. ${dns_data_ttl} ${dns_data_class} ${dns_record} ${dns_data_priority} ${dns_data_weight} ${dns_data_port} ${dns_data}.\n"
                        else
                            if [ "${dns_record}" == "TXT" ]; then
                                nsupdate_script+="; TXT add\n";
                                if [ ${Dns_Force_Flag} -ne 0 ]; then
                                    nsupdate_script+="prereq yxdomain ${dns_fqdn}.\n"
                                fi
                                nsupdate_script+="update add ${dns_fqdn}. ${dns_data_ttl} ${dns_data_class} ${dns_record}"
                                nsupdate_script+=" "
                                #nsupdate_script+="\""
                                nsupdate_script+="${dns_data}"
                                #nsupdate_script+="\""
                                nsupdate_script+="\n"
                            else
                                # SOA
                                if [ "${dns_fqdn}" == "${dns_zone_soa}" ]; then
                                    nsupdate_script+="; SOA add (${dns_record})\n";
                                else
                                    nsupdate_script+="prereq nxdomain ${dns_fqdn}.\n"
                                fi
                                nsupdate_script+="update add ${dns_fqdn}. ${dns_data_ttl} ${dns_data_class} ${dns_record} ${dns_data}\n"
                            fi
                        fi
                    fi
                fi
            fi
        fi

    fi

    #nsupdate_script+="debug\n"

    nsupdate_script+="send\n"

    #nsupdate_script+="answer\n"

    if [[ ${Verbose} =~ ^[0-9]+$ ]]; then
        if [ ${Verbose} -ge ${verbose_level} ]; then
            (>&2 printf "${nsupdate_script}")
        fi
    fi

    printf "${nsupdate_script}" | nsupdate ${Nsupdate_Args} ${nsupdate_key_args} &> /dev/null
    nsupdate_rc=$?

    if [ "${dns_zone_keyfile}" == "gsstsig" ] || [ "${dns_zone_keyfile}" == "oldgsstsig" ]; then
        # ugh, another windows workaround
        # https://bugzilla.redhat.com/show_bug.cgi?id=1394320

        local dns_lookup_rc=1

        if [ "${dns_record}" == "PTR" ]; then
            dnsLookup match "${dns_record}" "${dns_fqdn}" "${dns_data}" "${dns_server}" "${dns_server_port}" "${dns_zone_key}" "${dns_zone_keyfile}"
        else
            if [ "${dns_record}" == "CNAME" ]; then
                dnsLookup match "${dns_record}" "${dns_fqdn}" "${dns_data}" "${dns_server}" "${dns_server_port}" "${dns_zone_key}" "${dns_zone_keyfile}"
            else
                dnsLookup match "${dns_record}" "${dns_fqdn}" "${dns_data}" "${dns_server}" "${dns_server_port}" "${dns_zone_key}" "${dns_zone_keyfile}"
            fi
        fi
        dns_lookup_rc=$?

        dnsVerbose "dns_lookup_rc=${dns_lookup_rc}" ${verbose_level}
        if [ "${dns_action}" == "add" ] && [ ${dns_lookup_rc} -eq 0 ]; then
            nsupdate_rc=0
        fi
        if [ "${dns_action}" == "delete" ] && [ ${dns_lookup_rc} -ne 0 ]; then
            nsupdate_rc=0
        fi
    fi

    if [ ${nsupdate_rc} -eq 0 ]; then
        dnsVerbose "dns_lookup_rc=${dns_lookup_rc} [OK]" ${verbose_level}
    else
        dnsVerbose "dns_lookup_rc=${dns_lookup_rc} [ERROR]" ${verbose_level}
    fi

    dnsVerbose "nsupdate ${Nsupdate_Args} ${nsupdate_key_args} &> /dev/null [${nsupdate_rc}]" ${verbose_level}

    return ${nsupdate_rc}
}


# output a warning message
function dnsWarning() {
    local warning_arguments=$@

    local warning_message

    if [ ${#Dns_Status_Trace} -gt 0 ]; then
        dnsStatus
    fi

    warning_message="[WARNING]:"
    if [ ${#Dns_Status} -gt 0 ]; then
        warning_message+=" ${Dns_Status}"
    fi
    warning_message+=" ${warning_arguments[@]}"

    (>&2 dnsEcho "${warning_message}")
}


# validate ip address and standard output arpa zone (if appropriate)
function dnsZoneArpa() {
    Dns_Status_Trace="${FUNCNAME}" && dnsStatus

    local -u dns_record="${1}"
    local dns_data="${2}"

    local verbose_level=21

    if [ ${#dns_record} -eq 0 ] || [ ${#dns_data} -eq 0 ]; then
        return 0
    fi

    dnsVerbose "dns_record=${dns_record}" ${verbose_level}
    dnsVerbose "dns_data=${dns_data}" ${verbose_level}

    local dns_record_ip_family

    dns_record_ip_family=1

    local dns_record_ips=(A AAAA PTR)
    for dns_record_ip in ${dns_record_ips[@]}; do
        if [ "${dns_record}" == "${dns_record_ip}" ]; then
            if (ipcalc -c -4 "${dns_data}" &> /dev/null); then

                if [ "${dns_record_ip}" == "A" ] || [ "${dns_record_ip}" == "PTR" ]; then
                    # in-addr.arpa
                    dns_record_ip_family=4
                    # host nicely converts an ip address to in-addr reverse format
                    host ${Host_Args} "${dns_data}" 2> /dev/null | head -1 | sed -e 's#^Host[[:space:]]##g' | awk '{print $1}' | sed -e '/\.*$/s///g'
                    break
                fi
            else
                if (ipcalc -c -6 "${dns_data}" &> /dev/null); then

                    if [ "${dns_record_ip}" == "AAAA" ] || [ "${dns_record_ip}" == "PTR" ]; then
                        # ip6.arpa
                        dns_record_ip_family=6
                        # host nicely converts an ip address to ip6 reverse format
                        host ${Host_Args} "${dns_data}" 2> /dev/null | head -1 | sed -e 's#^Host[[:space:]]##g' | awk '{print $1}' | sed -e '/\.*$/s///g'
                        break
                    fi
                else
                    #dnsAlert "${dns_data} is an invalid IP address"
                    return 1
                fi
            fi
        fi
    done

    dnsVerbose "dns_record_ip_family=${dns_record_ip_family}" ${verbose_level}

    return ${dns_record_ip_family}
}


# output matching DNS_Zone config key value from config file
function dnsZoneConfig() {
    Dns_Status_Trace="${FUNCNAME}" && dnsStatus

    local dns_zone_config_value="${1}"
    local dns_config_file="${2}"
    local dns_config_view="${3}"

    local verbose_level=15

    if [ ${#dns_zone_config_value} -eq 0 ]; then
        return 1
    fi

    if [ ${#dns_config_file} -eq 0 ]; then
        dns_config_file="${Dns_Config_File}"
    fi

    if [ ${#dns_config_file} -eq 0 ]; then
        # is it OK *not* to have a config file?  should be ...
        dnsAlert "configuration file missing; value is empty"
        return 1
    else
        if [ ! -r "${dns_config_file}" ]; then
            dnsAlert "configuration file missing; '${dns_config_file}' file NOT readable"
            return 1
        fi
    fi

    dnsVerbose "dns_zone_config_value=${dns_zone_config_value}" ${verbose_level}
    dnsVerbose "dns_config_file=${dns_config_file}" ${verbose_level}
    if [ ${#dns_config_view} -gt 0 ]; then
        dnsVerbose "dns_config_view=${dns_config_view}" ${verbose_level}
    fi

    if [ ${#dns_config_view} -gt 0 ]; then
        dns_config_view+=","
    fi

    set -o pipefail

    local config_data config_data_rc
    local dns_zone_config_value_dots="${dns_zone_config_value//[^\.]}"
    local dns_zone_config_value_dots=${#dns_zone_config_value_dots}

    config_data_rc=1

    local config_direction
    while [ ${dns_zone_config_value_dots} -ge 0 ]; do

        if [[ "${dns_zone_config_value}" == *"arpa" ]]; then
            config_direction="reverse"
            config_data=$(sed -e '/[[:space:]]/s///g' "${dns_config_file}" 2> /dev/null | egrep -e "^Dns_Zone=.*,${dns_zone_config_value},${dns_config_view}" | head -1 | awk -F# '{print $1}')
            config_data_rc=$?
            config_data=${config_data#*=}
        else
            config_direction="forward"
            config_data=$(sed -e '/[[:space:]]/s///g' "${dns_config_file}" 2> /dev/null | egrep -e "^Dns_Zone=${dns_zone_config_value},.*,${dns_config_view}" | head -1 | awk -F# '{print $1}')
            config_data_rc=$?
            config_data=${config_data#*=}
        fi

        dnsVerbose "dns_zone_config_value_dots=${dns_zone_config_value_dots} (${dns_zone_config_value}) [${config_direction}]" ${verbose_level}
        dnsVerbose "config_data=${config_data} (${dns_zone_config_value}) [${config_direction}]" ${verbose_level}

        if [ ${#config_data} -gt 0 ]; then
            dnsVerbose "config_data=${config_data}" ${verbose_level}
            break;
        fi

        dns_zone_config_value=${dns_zone_config_value#*.}
        let dns_zone_config_value_dots=${dns_zone_config_value_dots}-1
    done

    echo ${config_data}

    # return pipefail result code
    return ${config_data_rc}

}


# output valid dns zone keyfile
function dnsZoneKeyfile() {
    Dns_Status_Trace="${FUNCNAME}" && dnsStatus

    local -l dns_zone="${1}"
    local dns_server="${2}"
    local dns_server_port="${3}"
    local dns_zone_key="${4}"
    local dns_view="${5}"

    local verbose_level=17

    # only allow public & private views
    if [ "${dns_view}" != "private" ] && [ "${dns_view}" != "public" ]; then
        dns_view=""
    fi

    dnsVerbose "dns_zone=${dns_zone}" ${verbose_level}
    dnsVerbose "dns_server=${dns_server} (${dns_server_port})" ${verbose_level}
    dnsVerbose "dns_zone_key=${dns_zone_key}" ${verbose_level}
    dnsVerbose "dns_view=${dns_view}" ${verbose_level}

    local dns_zone_keyfile

    if [ ${#dns_zone} -eq 0 ]; then
        return 1
    fi

    local -u dns_user
    local dns_pass

    if [ ${#dns_zone_key} -gt 0 ]; then
        if [ -r "${dns_zone_key}" ]; then
            dns_zone_keyfile="${dns_zone_key}"
            dns_zone_key=$(grep ^key.*\{ "${dns_zone_key}" 2> /dev/null | awk '{print $2}' | sed -e '/"/s///g' -e "/'/s///g")
            if [ ${#dns_zone_key} -eq 0 ]; then
                dnsAlert "'${dns_zone_keyfile}' invalid key file"
                return 1
                # invalid key, reset
                dns_zone_key="${dns_zone_keyfile}"
                dns_zone_keyfile=""
            fi
        else
            if [ -f "${dns_zone_key}" ]; then
                dnsAlert "'${dns_zone_key}' file NOT readable"
                return 1
            else
                if [[ "${dns_zone_key}" == *"@"* ]] && [[ "${dns_zone_key}" == *":"* ]]; then
                    dns_user=${dns_zone_key%:*}
                    dns_pass=${dns_zone_key##*:}
                    dns_zone_keyfile="gsstsig"
                fi
            fi
        fi
    fi

    local dns_dependencies dns_dependency dns_dependency_exec dns_dependency_fail

    dns_dependency_fail=1
    if [ "${dns_zone_keyfile}" == "gsstsig" ] && [ ${#dns_user} -gt 0 ] && [ ${#dns_pass} -gt 0 ]; then
        dnsVerbose "dns_user=${dns_user}, dns_pass=${dns_pass}" ${verbose_level}

        dns_dependencies=()
        dns_dependencies+=(kinit)
        for dns_dependency in ${dns_dependencies[@]}; do
            dnsVerbose "dns_dependency=${dns_dependency}" $((${verbose_level}+20))
            [ ${#dns_dependency} -eq 0 ] && continue
            dns_dependency_exec=$(type -P "${dns_dependency}")
            if [ ! -f "${dns_dependency_exec}" ] && [ ! -x "${dns_dependency_exec}" ]; then
                dnsAlert "dns dependency '${dns_dependency_exec}' file NOT found executable"
                dns_dependency_fail=0
                break
            fi
        done
        unset -v dns_dependency dns_dependency_exec

        if [ ${dns_dependency_fail} -eq 0 ]; then
            return 1
        fi

        local kinit_rc

        kinit_rc=1

        set -o pipefail

        # todo: more testing ...
        echo "${dns_pass}" | kinit "${dns_user}" &> /dev/null
        kinit_rc=$?

        dnsVerbose "kinit_rc=${kinit_rc}" ${verbose_level}

        if [ ${kinit_rc} -ne 0 ]; then
            dnsAlert "kinit failed for '${dns_user}'"
            return 1
        fi
    fi

    local dns_zone_keyfiles nsupdate_key_args

    if [ ${#dns_zone_keyfile} -eq 0 ]; then
        dns_zone_keyfiles=()
        dns_zone_keyfiles+=($(find ${Dns_Dir}/etc -type f -name "named*zone.key" 2> /dev/null | sort -u))
        dns_zone_keyfiles+=($(find /etc -type f -name "named*zone.key" 2> /dev/null | sort -u))
        if [ -r /etc/rndc.key ]; then
            dns_zone_keyfiles+=(/etc/rndc.key)
        fi
        if [ -r /etc/rndc.conf ]; then
            dns_zone_keyfiles+=(/etc/rndc.conf)
        fi
        if [ ${#dns_zone_key} -eq 0 ] && [ ${#dns_zone_keyfile} -eq 0 ] && [ ${#dns_view} -eq 0 ]; then
            dns_zone_keyfiles+=(none)
        fi
    else
        dns_zone_keyfiles=("${dns_zone_keyfile}")
    fi

    if [ ${#dns_zone_key} -gt 0 ] || [ ${#dns_zone_keyfile} -gt 0 ] || [ ${#dns_view} -gt 0 ]; then
        for dns_zone_keyfile in "${dns_zone_keyfiles[@]}"; do
            [ "${dns_zone_keyfile}" == "" ] && continue
            [ "${dns_zone_keyfile}" == "none" ] && continue
            [ ! -r "${dns_zone_keyfile}" ] && continue

            if [ ${#dns_zone_key} -gt 0 ]; then
                grep "^key.*[$|\"]${dns_zone_key}[$|\"].*{" "${dns_zone_keyfile}" &> /dev/null
                if [ $? -eq 0 ]; then
                    # found matching keyfile
                    break
                fi
            fi

            if [ ${#dns_view} -gt 0 ]; then
                if [[ "${dns_zone_keyfile}" == *".${dns_view}.zone.key"* ]]; then
                    # found matching keyfile
                    if [ ${#dns_zone_key} -eq 0 ]; then
                        dns_zone_key=$(grep ^key.*\{ "${dns_zone_keyfile}" 2> /dev/null | awk '{print $2}' | sed -e '/"/s///g' -e "/'/s///g")
                    fi
                    break
                fi
            fi
        done
    fi

    local dns_zone_key_valid=1 # false

    if [ ${#dns_zone_keyfile} -gt 0 ]; then
        if [ "${dns_zone_keyfile}" != "none" ]; then
            if [ "${dns_zone_keyfile}" == "gsstsig" ]; then
                dns_zone_keyfiles=("gsstsig" "oldgsstsig")
            else
                dns_zone_keyfiles=("${dns_zone_keyfile}" none)
            fi
        fi
    fi

    local local nsupdate_key_args nsupdate_rc nsupdate_script
    if [ ${#dns_server} -eq 0 ]; then
        if [ -r "${dns_zone_keyfile}" ]; then
            dns_zone_key_valid=0 # true
        fi
    else
        for dns_zone_keyfile in "${dns_zone_keyfiles[@]}"; do
            [ "${dns_zone_keyfile}" == "" ] && continue
            dnsVerbose "(1) dns_zone_keyfile=${dns_zone_keyfile}" ${verbose_level}

            unset -v nsupdate_key_args

            if [ "${dns_zone_keyfile}" != "none" ] && [ -r "${dns_zone_keyfile}" ]; then
                nsupdate_key_args="-k ${dns_zone_keyfile}"
            else
                nsupdate_key_args=""
            fi

            nsupdate_script="server ${dns_server} ${dns_server_port}\n"
            nsupdate_script+="zone ${dns_zone}.\n"
            if [ "${dns_zone_keyfile}" == "gsstsig" ]; then
                nsupdate_script+="gsstsig\n"
            fi
            if [ "${dns_zone_keyfile}" == "oldgsstsig" ]; then
                nsupdate_script+="oldgsstsig\n"
            fi
            #nsupdate_script+="debug\n"
            nsupdate_script+="send\n"
            nsupdate_script+="answer\n"

            #(>&2 printf "${nsupdate_script}")
            if [ "${dns_zone_keyfile}" == "gsstsig" ] || [ "${dns_zone_keyfile}" == "oldgsstsig" ]; then
                # https://bugzilla.redhat.com/show_bug.cgi?id=1394320
                set +o pipefail
                printf "${nsupdate_script}" | nsupdate ${Nsupdate_Args} ${nsupdate_key_args} 2> /dev/null | grep -q ".*ANY.*TSIG.*NOERROR[[:space:]]0"
            else
                printf "${nsupdate_script}" | nsupdate ${Nsupdate_Args} ${nsupdate_key_args} &> /dev/null
            fi
            nsupdate_rc=$?

            dnsVerbose "nsupdate ${Nsupdate_Args} ${nsupdate_key_args} &> /dev/null [${nsupdate_rc}]" ${verbose_level}

            if [ ${nsupdate_rc} -eq 0 ]; then
                # success
                if [ ${#dns_zone_key} -eq 0 ] && [ "${dns_zone_keyfile}" != "none" ] && [ -r "${dns_zone_keyfile}" ]; then
                    dns_zone_key=$(grep ^key.*\{ "${dns_zone_keyfile}" 2> /dev/null | awk '{print $2}' | sed -e '/"/s///g' -e "/'/s///g")
                fi
                if [ "${dns_zone_keyfile}" == "none" ]; then
                    dns_zone_key=""
                    dns_zone_keyfile=""
                fi
                dns_zone_key_valid=0 # true
                break
            fi

            if [ -f "${dns_zone_keyfile}" ]; then
                dnsWarning "${dns_server} rejected zone key file '${dns_zone_keyfile}'"
            else
                if [ ${#dns_zone_keyfile} -gt 0 ] && [ "${dns_zone_keyfile}" != "none" ]; then
                    dnsWarning "${dns_server} rejected zone key '${dns_zone_keyfile}'"
                else
                    dnsWarning "${dns_server} rejected empty key"
                fi
            fi

        done
    fi

    dnsVerbose "dns_zone_key=${dns_zone_key} [${dns_zone_key_valid}], dns_zone_keyfile=${dns_zone_keyfile}, dns_zone_keyfiles=${dns_zone_keyfiles[@]}" ${verbose_level}

    if [ ${#dns_zone_keyfile} -gt 0 ] && [ ${dns_zone_key_valid} -eq 0 ]; then
        printf "${dns_zone_keyfile}"
        if [ ${#dns_zone_key} -gt 0 ]; then
            printf ",${dns_zone_key}"
        fi
        printf "\n"
    else
        if [ ${#dns_zone_keyfile} -gt 0 ] && [ ! -r ${dns_zone_keyfile} ]; then
            dns_zone_key_valid=1 # false
        fi
        dns_zone_key=""
        dns_zone_keyfile=""
    fi

    dnsVerbose "dns_zone_key=${dns_zone_key} [FINAL]" ${verbose_level}
    dnsVerbose "dns_zone_keyfile=${dns_zone_keyfile} (${dns_zone_key_valid}) [FINAL]" ${verbose_level}

    return ${dns_zone_key_valid}
}


# output dns zone based on a valid SOA
function dnsZoneSOA() {
    Dns_Status_Trace="${FUNCNAME}" && dnsStatus

    local soa_value="${1^^}"
    local dns_fqdn="${2}"
    local dns_server="${3}"
    local dns_server_port="${4}"
    local dns_zone_key="${5}"
    local dns_zone_keyfile="${6}"

    local verbose_level=18

    dnsVerbose "dns_fqdn=${dns_fqdn}" ${verbose_level}

    local dns_lookup_rc=1

    local dns_soa

    local dns_fqdn_dots="${dns_fqdn//[^\.]}"
    local dns_fqdn_dots=${#dns_fqdn_dots}

    while [ ${dns_fqdn_dots} -ge 0 ]; do
        dnsVerbose "dns_fqdn_dots=${dns_fqdn_dots} (${dns_fqdn})" ${verbose_level}
        dns_soa=$(dnsLookup value "SOA" "${dns_fqdn}" "${dns_fqdn}" "${dns_server}" "${dns_server_port}" "${dns_zone_key}" "${dns_zone_keyfile}")
        if [ ${#dns_soa} -gt 0 ]; then
            dns_lookup_rc=0
            break
        fi
        dns_fqdn=${dns_fqdn#*.}
        let dns_fqdn_dots=${dns_fqdn_dots}-1
    done

    dnsVerbose "dns_soa=${dns_soa} (${dns_fqdn})" ${verbose_level}
    dnsVerbose "dns_fqdn=${dns_fqdn}, dns_lookup_rc=${dns_lookup_rc}" ${verbose_level}

    local dns_soa_result

    # name, class, soa, serial, refresh, retry, expire, ttl

    if [ "${soa_value}" == "MNAME" ]; then
        dns_soa_result=${dns_soa}
        dns_soa_result=${dns_soa_result%% *}
        dns_soa_result=${dns_soa_result%.*}
    fi

    if [ "${soa_value}" == "RECURSE" ]; then
        dns_soa_result=${dns_fqdn}
    fi

    if [ "${soa_value}" == "RNAME" ]; then
        dns_soa_result=${dns_soa}
        dns_soa_result=${dns_soa_result#* }
        dns_soa_result=${dns_soa_result%% *}
        dns_soa_result=${dns_soa_result%.*}
        if [[ "${dns_soa_result}" == *"invalid"* ]]; then
            # todo; review impact; somewhat misleading
            dns_soa_result=""
        fi
    fi

    dns_soa_result=${dns_soa_result,,}

    if [ ${dns_lookup_rc} -eq 0 ] && [ ${#dns_soa_result} -gt 0 ]; then
        echo "${dns_soa_result}"
        return 0
    fi

    return 1

}


# output a 'usage' message and exit with a non-zero return code
function usage() {
    # 'this' (name) points to 'that' (data)
    # e.g.
    # a joseph.tingiris.net 192.168.12.18
    # cname tingiris.net joseph.tingiris.net
    printf "\nusage:\n\n%s <action> <record> <name> <data> [options]\n\n" "${0}"

    if [ "${Dns_Actions}" != "" ]; then
        printf "supported actions:\n\n"
        let Dns_Action_Count=0
        for Dns_Action in ${Dns_Actions[@]}; do
            if [ ${Dns_Action_Count} -eq 0 ]; then
                printf "    ${Dns_Action}"
            else
                printf ", ${Dns_Action}"
            fi
            let Dns_Action_Count=${Dns_Action_Count}+1
        done
        printf "\n\n"
        unset -v Dns_Action
    fi

    if [ "${Dns_Records}" != "" ]; then
        printf "supported records:\n\n"
        let Dns_Record_Count=0
        for Dns_Record in ${Dns_Records[@]}; do
            if [ ${Dns_Record_Count} -eq 0 ]; then
                printf "    ${Dns_Record}"
            else
                printf ", ${Dns_Record}"
            fi
            let Dns_Record_Count=${Dns_Record_Count}+1
        done
        printf "\n\n"
        unset -v Dns_Record
    fi

    printf "supported options:\n\n"
    printf "    -a|--all                    = automatically action all records, e.g. A and PTR\n"
    printf "    -c|--class <string>         = specify dns data class, default ${Default_Data_Class}\n"
    printf "    -d|--debug <level>          = increase debug verbosity\n"
    printf "    -f|--force                  = force action to complete; bypass safety checks\n"
    printf "    -h|--help                   = show usage help and exit\n";
    printf "    -k|--key <file|name>        = specify key name or key file\n"
    printf "    -m|--multiple               = allow adding multiple records of the same type\n"
    printf "    -p|--priority <integer>     = specify dns data priority, e.g. for MX records, default ${Default_Data_Priority}\n"
    printf "    -P|--data-port <integer>    = specify dns data port, e.g. for SRV records, default ${Default_Data_Port}\n"
    printf "    -s|--server <ip>            = specify dns server to action, default automatically resolve\n"
    printf "    -S|--server-port <integer>  = specify dns server port, default 53\n"
    printf "    -t|--ttl <integer>          = specify dns data time to live, default ${Default_Data_TTL} seconds\n"
    printf "    -v|--view <name>            = specify dns view name, default automatic\n"
    printf "    -w|--weight <integer>       = specify dns data weight, e.g. for SRV records, default ${Default_Data_Weight}\n"
    printf "    -z|--zone <name>            = specify dns zone name\n"
    printf "\n\n"

    # todo: add examples

    if [ ${#1} -ne 0 ]; then
        local usage_message="${@}"
        printf "NOTE: %s\n\n" "${usage_message}"
    fi
    exit 1
}

if [ "$(type -t verbose)" != "function" ]; then
    function verbose() {
        local verbose_arguments=($@)
        local verbose_level verbose_message

        if [ ${#2} -gt 0 ]; then
            verbose_message="${verbose_arguments[@]}"
            verbose_level=${verbose_arguments[${#verbose_arguments[@]}-1]}
            if [[ ${verbose_level} =~ ^[0-9]+$ ]]; then
                verbose_message="${verbose_message% *}"
            else
                verbose_level=0
            fi
        else
            verbose_message="${1}"
            verbose_level=0
        fi

        if [ ${verbose_level} -eq 0 ]; then
            # do not display level 0 messages
            return
        fi

        if [[ ${Verbose} =~ ^[0-9]+$ ]]; then
            if [ ${verbose_level} -le ${Verbose} ]; then
                (>&2 printf "%b\n" "${verbose_message}")
            fi
        fi
    }
fi

function dnsVerbose() {
    if [[ ${Verbose} =~ ^[0-9]+$ ]]; then
        if [ ${Verbose} -gt 1 ]; then
            verbose ${Dns_Status} $@
        else
            verbose $@
        fi
    else
        verbose $@
    fi
}

#
# Main
#

Failure_Reason=""
Dns_Basename=$(basename ${0})

Dns_Status_Trace="${Dns_Basename}"

Dns_Status_Trace="${Dns_Basename}" && dnsStatus

#
# validate dns directory
#

# config file must exist?

if [ -r "/etc/${Dns_Config_Basename}" ]; then
    Dns_Config_File="/etc/${Dns_Config_Basename}"
fi

if [ "${BASH_SOURCE}" != "${0}" ]; then
    Dns_Dir=$(dirname "$(readlink -e "${BASH_SOURCE}")")
else
    Dns_Dir=$(dirname "$(readlink -e "${0}")")
fi

if [ -d "${Dns_Dir}/../zone" ] && [ -r "${Dns_Dir}/../zone" ]; then
    Dns_Dir=$(dirname "${Dns_Dir}")
fi

if [ ${#Dns_Dir} -eq 0 ]; then
    aborting "dns directory value is empty"
fi

if [ ! -d "${Dns_Dir}" ] || [ ! -r "${Dns_Dir}" ]; then
    aborting "dns directory; '${Dns_Dir}' directory NOT readable"
fi

if [ -f "${Dns_Dir}/etc/named.primary.conf" ] && [ -f "${Dns_Dir}/etc/named.secondary.conf" ]; then
    if [ ${#Dns_Config_File} -eq 0 ] && [ -r "${Dns_Dir}/etc/${Dns_Config_Basename}" ]; then
        Dns_Config_File="${Dns_Dir}/etc/${Dns_Config_Basename}"
    fi
    if [ -r /etc/named.conf ]; then
        # primary & secondary servers using this script additionally require these ...
        if [ -r /etc/rndc.key ] || [ -r /etc/rndc.conf ]; then
            Dns_Dependencies+=(rndc)
            Dns_Rndc_Flag=0
        fi
    fi
fi

PATH=${Dns_Dir}/bin:${Dns_Dir}/sbin:${PATH}

#
# validate dependencies
#

for Dns_Dependency in ${Dns_Dependencies[@]}; do
    [ ${#Dns_Dependency} -eq 0 ] && continue
    Dns_Dependency_Exec=$(type -P "${Dns_Dependency}")
    if [ ! -f "${Dns_Dependency_Exec}" ] && [ ! -x "${Dns_Dependency_Exec}" ]; then
        aborting "dependency missing; '${Dns_Dependency}' file NOT executable"
    fi
done
unset -v Dns_Dependency Dns_Dependency_Exec

#
# validate BASH_SOURCE
#

# for reusable functions; return if this script was sourced
if [ "${BASH_SOURCE}" != "${0}" ]; then
    if [ ${#Dns_Config_File} -eq 0 ]; then
        aborting "${Dns_Config_Basename} file NOT found"
    fi
    return
else
    # first four arguments are required (for everything except lookup)
    if [ "${1,,}" == "delete" ] || [ "${1,,}" == "lookup" ]; then
        if [ ${#2} -eq 0 ] || [ ${#3} -eq 0 ]; then
            usage "invalid number of arguments; the first 3 ${1} arguments are required"
        fi
    else
        if [ ${#1} -eq 0 ] || [ ${#2} -eq 0 ] || [ ${#3} -eq 0 ] || [ ${#4} -eq 0 ]; then
            usage "invalid number of arguments; the first 4 arguments are required"
        fi
    fi
fi

#
# Main (cli)
#

Dns_Date=0

#
# capture arguments
#

Arguments=$@

#
# validate dns action
#

Dns_Action_Valid=1
for Dns_Action in ${Dns_Actions[@]}; do
    if [ "${1,,}" == "${Dns_Action}" ]; then
        Dns_Action_Valid=0
        break
    fi
done
if [ ${Dns_Action_Valid} -eq 1 ]; then
    usage "invalid action '${1}'"
else
    shift
fi

#
# validate dns record (type)
#

Dns_Record_Valid=1
for Dns_Record in ${Dns_Records[@]}; do
    if [ "${1^^}" == "${Dns_Record}" ]; then
        Dns_Record_Valid=0
        break
    fi
done
if [ ${Dns_Record_Valid} -eq 1 ]; then
    if [ "${Dns_Action}" == "lookup" ]; then
        Dns_Record="${1^^}"
        shift
    else
        usage "invalid record '${1^^}'"
    fi
else
    shift
fi

#
# validate name
#

declare -l Dns_Name=$(echo "${1}" | sed -e 's#\.\.*#\.#g' -e 's#^\.##g' -e 's#\.$##g' -e '/\.*$/s///g')

if [ ${#Dns_Name} -eq 0 ] || [ "${Dns_Name:0:1}" == "-" ]; then
    aborting "invalid dns name '${1}'"
else
    shift
fi

#
# validate data
#

Dns_Data="${1}"
if [ ${#Dns_Data} -eq 0 ]; then
    if [ "${Dns_Action}" == "delete" ] || [ "${Dns_Action}" == "lookup" ]; then
        Dns_Data=${Dns_Name}
    fi
else
    if [ "${Dns_Action}" == "delete" ] || [ "${Dns_Action}" == "lookup" ]; then
        if [ "${1:0:1}" == "-" ]; then
            Dns_Data=${Dns_Name}
        else
            shift
        fi
    else
        shift
    fi
fi

if [ "${1:0:1}" != "-" ]; then
    if [ ${#1} -gt 0 ]; then
        usage "invalid argument '${1}'"
    fi
else

    #
    # parse cli options
    #

    # translate long options to short
    for arg; do
        quote=""
        case "${arg}" in
            -all|--all)
                args="${args}-f "
                ;;
            -class|--class)
                args="${args}-c "
                ;;
            -debug|--debug)
                args="${args}-d "
                ;;
            -force|--force)
                args="${args}-f "
                ;;
            -help|--help)
                args="${args}-h "
                ;;
            -key|--key)
                args="${args}-k "
                ;;
            -multi|--multi|-multiple|--multiple)
                args="${args}-m "
                ;;
            -server-port|--server-port)
                args="${args}-S "
                ;;
            -priority|--priority)
                args="${args}-p "
                ;;
            -server|--server)
                args="${args}-s "
                ;;
            -ttl|--ttl)
                args="${args}-t "
                ;;
            -view|--view)
                args="${args}-v "
                ;;
            -zone|--zone)
                args="${args}-z "
                ;;
            *)
                [[ "${arg:0:1}" == "-" ]] || quote="\""
                args="${args}${quote}${arg}${quote} "
                ;;
        esac
    done
    eval set -- ${args}

    # process short options
    while getopts ":ac:d:fhk:mp:P:s:S:t:v:w:z:" option; do
        case "${option}" in
            a)
                Dns_All_Flag=0 # true
                ;;
            c)
                Dns_Data_Class=${OPTARG}
                ;;
            d)
                Verbose=${OPTARG}
                declare -i Verbose_Level=${OPTARG}
                ;;
            f)
                Dns_Force_Flag=0 # true
                ;;
            h)
                usage
                ;;
            k)
                Dns_Zone_Key=${OPTARG}
                ;;
            m)
                Dns_Multiple_Flag=0 # true
                ;;
            p)
                Dns_Data_Priority=${OPTARG}
                ;;
            P)
                Dns_Data_Port=${OPTARG}
                ;;
            s)
                Dns_Server=${OPTARG}
                ;;
            S)
                Dns_Server_Port=${OPTARG}
                ;;
            t)
                Dns_Data_TTL=${OPTARG}
                ;;
            v)
                Dns_View=${OPTARG}
                ;;
            w)
                Dns_Data_Weight=${OPTARG}
                ;;
            z)
                Dns_Zone=${OPTARG}
                ;;
            :)
                aborting "option '-${OPTARG}' requires an argument"
                ;;
            *)
                aborting "unknown option '${@}'"
                ;;
        esac
    done

fi

#
# Validate Verbose & Verbose_Level
#

if [[ ! ${Verbose} =~ ^[0-9]+$ ]]; then
    if [[ ${VERBOSE} =~ ^[0-9]+$ ]]; then
        declare -i Verbose=${VERBOSE}
    else
        declare -i Verbose=4 # WARNING
    fi
fi

if [[ ! ${Verbose_Level} =~ ^[0-9]+$ ]]; then
    declare -i Verbose_Level=0
fi

if [ ${Verbose_Level} -eq 0 ]; then
    if [ "${Dns_Action}" == "add" ] || [ "${Dns_Action}" == "delete" ] || [ "${Dns_Action}" == "update" ]; then
        Dns_Alert_Mail_Flag=0 # true
    fi
fi

dnsVerbose "Verbose = ${Verbose}" ${Verbose_Level}
dnsVerbose "Dns_Basename=${Dns_Basename}" ${Verbose_Level}
dnsVerbose "Dns_Dir=${Dns_Dir}" ${Verbose_Level}
dnsVerbose "Dns_Action=${Dns_Action}" ${Verbose_Level}
dnsVerbose "Dns_Record=${Dns_Record}" ${Verbose_Level}
dnsVerbose "Dns_Name=${Dns_Name}" ${Verbose_Level}
dnsVerbose "Dns_Data=${Dns_Data}" ${Verbose_Level}

#
# validate flags
#

if [ ${Dns_All_Flag} -eq 0 ]; then
    dnsVerbose "Dns_All_Flag = ${Dns_All_Flag}" ${Verbose_Level}
fi

if [ ${Dns_Force_Flag} -eq 0 ]; then
    dnsVerbose "Dns_Force_Flag = ${Dns_Force_Flag}" ${Verbose_Level}
fi

if [ ${Dns_Multiple_Flag} -eq 0 ]; then
    dnsVerbose "Dns_Multiple_Flag = ${Dns_Multiple_Flag}" ${Verbose_Level}
fi

#
# validate dns zone arpa
#

Dns_Zone_Arpa=$(dnsZoneArpa "${Dns_Record}" "${Dns_Data}")
Dns_Record_IP_Family=$?

dnsVerbose "Dns_Zone_Arpa=${Dns_Zone_Arpa}" ${Verbose_Level}

#
# validate dns zone
#

if [ ${#Dns_Zone} -gt 0 ]; then
    Dns_Zone=$(echo "${Dns_Zone}" | sed -e 's#\.\.*#\.#g' -e 's#^\.##g' -e 's#\.$##g');
fi

#
# validate dns record ip family
#

dnsVerbose "Dns_Record_IP_Family=${Dns_Record_IP_Family}" ${Verbose_Level}

if [ "${Dns_Record}" == "A" ] || [ "${Dns_Record}" == "AAAA" ] || [ "${Dns_Record}" == "PTR" ]; then
    if [ "${Dns_Action}" != "delete" ] && [ "${Dns_Action}" != "lookup" ]; then
        if [ ${Dns_Record_IP_Family} -ne 4 ] && [ ${Dns_Record_IP_Family} -ne 6 ]; then
            aborting "${Dns_Data} is an invalid IP address for an ${Dns_Record} record"
        fi
    fi
fi

#
# validate dns fully qualified domain name (fqdn)
#

if [ ${#Dns_Zone_Arpa} -gt 0 ] && [ ${#Dns_FQDN} -eq 0 ]; then
    Dns_FQDN=$(dnsFQDN "${Dns_Name}" "${Dns_Zone_Arpa}" "${Dns_Zone}" "${Dns_Config_File}" "${Dns_View}")
fi

if [ ${#Dns_Record} -gt 0 ] && [ ${#Dns_FQDN} -eq 0 ]; then
    Dns_FQDN=$(dnsFQDN "${Dns_Name}" "${Dns_Record}" "${Dns_Zone}" "${Dns_Config_File}" "${Dns_View}")
fi

if [ ${#Dns_FQDN} -eq 0 ]; then
    aborting "unable to determine fully qualified domain name"
else
    dnsVerbose "Dns_FQDN=${Dns_FQDN}" ${Verbose_Level}
fi

#
# validate data
#

if ! (dnsDataValid "${Dns_Record}" "${Dns_FQDN}" "${Dns_Data}"); then
    aborting "'${Dns_Data}' is invalid data for a ${Dns_Record} record"
fi

#
# validate data class
#

if [ "${Dns_Data_Class}" != "IN" ]; then
    Dns_Data_Class=${Default_Data_Class}
fi
Dns_Data_Class=${Dns_Data_Class^^}

dnsVerbose "Dns_Data_Class=${Dns_Data_Class}" ${Verbose_Level}

#
# validate data port
#

if [[ ! ${Dns_Data_Port} =~ ^[0-9]+$ ]]; then
    Dns_Data_Port=${Default_Data_Port}
fi

dnsVerbose "Dns_Data_Port=${Dns_Data_Port}" ${Verbose_Level}

#
#
# validate data priority
#

if [[ ! ${Dns_Data_Priority} =~ ^[0-9]+$ ]]; then
    if [ "${Dns_Record}" == "SRV" ]; then
        let Dns_Data_Priority=${Default_Data_Priority}*10
    else
        Dns_Data_Priority=${Default_Data_Priority}
    fi
fi

dnsVerbose "Dns_Data_Priority=${Dns_Data_Priority}" ${Verbose_Level}

#
# validate data ttl
#

if [[ ! ${Dns_Data_TTL} =~ ^[0-9]+$ ]]; then
    Dns_Data_TTL=${Default_Data_TTL}
fi

dnsVerbose "Dns_Data_TTL=${Dns_Data_TTL}" ${Verbose_Level}

#
# validate data weight
#

if [[ ! ${Dns_Data_Weight} =~ ^[0-9]+$ ]]; then
    Dns_Data_Weight=${Default_Data_Weight}
fi

dnsVerbose "Dns_Data_Weight=${Dns_Data_Weight}" ${Verbose_Level}

#
# validate dns view
#

# dns view is optional; the default view will be whatever the remote named assigns to the dns server ip
if [ ${#Dns_View} -gt 0 ]; then
    dnsVerbose "Dns_View=${Dns_View}" ${Verbose_Level}
fi

#
# validate dns zone
#

# dns zone is optional; the default zone will be whatever the record is parsed to be
if [ ${#Dns_Zone} -gt 0 ]; then
    dnsVerbose "Dns_Zone=${Dns_Zone}" ${Verbose_Level}
fi

#
# validate dns zone
#

#
# dns zone key is optional; the default zone will be whatever the remote view dicatates
#

if [ ${#Dns_Zone_Key} -gt 0 ]; then
    dnsVerbose "Dns_Zone_Key=${Dns_Zone_Key}" ${Verbose_Level}
fi

#
# final validation
#

if [ ! -d "${Dns_Dir}" ] || [ ! -r "${Dns_Dir}" ]; then
    aborting "'${Dns_Dir}' directory NOT readable"
fi

if [ ${#Dns_Action} -eq 0 ]; then
    aborting "Dns_Action is empty"
fi

if [ ${#Dns_Record} -eq 0 ]; then
    aborting "Dns_Record is empty"
fi

if [ ${#Dns_FQDN} -eq 0 ]; then
    aborting "Dns_FQDN is empty"
fi

if [ ${#Dns_Data} -eq 0 ]; then
    aborting "Dns_Data is empty"
fi

if [ "${Dns_Data_Class}" != "IN" ]; then
    aborting "Dns_Data_Class is NOT 'IN'"
fi

if [[ ! ${Dns_Data_Port} =~ ^[0-9]+$ ]]; then
    aborting "Dns_Data_Port is NOT an integer"
fi

if [[ ! ${Dns_Data_Priority} =~ ^[0-9]+$ ]]; then
    aborting "Dns_Data_Priority is NOT an integer"
fi

if [[ ! ${Dns_Data_TTL} =~ ^[0-9]+$ ]]; then
    aborting "Dns_Data_TTL is NOT an integer"
fi

if [[ ! ${Dns_Data_Weight} =~ ^[0-9]+$ ]]; then
    aborting "Dns_Data_Weight is NOT an integer"
fi

#
# validate what resource records should be actioned
#

Dns_RRS=()
if [ ${Dns_All_Flag} -eq 1 ]; then
    Dns_RRS=(${Dns_Record})
else
    if [ "${Dns_Record}" == "A" ] || [ "${Dns_Record}" == "AAAA" ]; then
        Dns_RRS=(${Dns_Record} PTR)
    else
        if [ "${Dns_Record}" == "PTR" ]; then
            if [ ${Dns_Record_IP_Family} -eq 4 ]; then
                Dns_RRS=(${Dns_Record} A)
            else
                if [ ${Dns_Record_IP_Family} -eq 6 ]; then
                    Dns_RRS=(${Dns_Record} AAAA)
                else
                    aborting "${Dns_Data} is NOT a valid IP address"
                fi
            fi
        else
            Dns_RRS=(${Dns_Record})
        fi
    fi
fi

dnsVerbose "Dns_RRS=${Dns_RRS[@]}" ${Verbose_Level}

#
# validate dns admin email
#

if ! Dns_Alert_Email=$(dnsConfig Dns_Alert_Email); then
    Dns_Alert_Email=root
fi

dnsVerbose "Dns_Alert_Email=${Dns_Alert_Email}" ${Verbose_Level}

Dns_Status_Trace="${Dns_Basename}" && dnsStatus

####################################################################################################################################
####################################################################################################################################
####################################################################################################################################
####################################################################################################################################
####################################################################################################################################

# !!!!!! everything up to this point is mutually exclusive with regard to either forward or reverse lookups

Dns_RC=0

for Dns_RR in ${Dns_RRS[@]}; do
    Dns_RR=${Dns_RR^^}

    dnsVerbose "Dns_RR=${Dns_RR}" ${Verbose_Level}

    unset -v Dns_Action_RR Dns_Action_RRS
    unset -v Dns_Data_RR Dns_FQDN_RR
    unset -v Dns_Server_RR Dns_Server_IP_RR Dns_Server_Port_RR
    unset -v Dns_Status Dns_Status_RR
    unset -v Dns_View_RR
    unset -v Dns_Zone_Arpa_RR Dns_Zone_RR Dns_Zone_Config_RR Dns_Zone_SOA_RR Dns_Zone_Key_RR Dns_Zone_Keyfile_RR
    unset -v Dns_Zone_Reference_RR

    #
    # validate forward/reverse dns FQDN
    #

    Dns_Data_RR="${Dns_Data}"
    Dns_FQDN_RR="${Dns_FQDN}"

    # it's possible that the forward and reverse authoritative nameservers are different!
    if [ ${#Dns_Zone_Arpa} -gt 0 ] && [ "${Dns_RR}" == "PTR" ]; then
        Dns_Data_RR="${Dns_FQDN}"
        Dns_FQDN_RR="${Dns_Zone_Arpa}"
    fi

    Dns_Status_Trace="${Dns_Basename}" && dnsStatus

    if [ ${#Dns_FQDN_RR} -eq 0 ]; then
        dnsAlert "can't validate authoritative dns server for '${Dns_FQDN}' ${Dns_RR}' '${Dns_Data_RR}' record; no FQDN"
        Dns_RC=1
        continue
    fi

    Dns_Status_Trace="${Dns_Basename}" && dnsStatus

    dnsVerbose "Dns_FQDN_RR=${Dns_FQDN_RR}" ${Verbose_Level}

    dnsVerbose "Dns_Data_RR=${Dns_Data_RR} [INITIAL]" ${Verbose_Level}

    #
    # validate (authoritative) dns server(s)
    #

    if [ "${#Dns_Server}" -gt 0 ]; then
        if [ "${Dns_Action}" == "lookup" ]; then
            if [ ${Dns_Force_Flag} -ne 0 ]; then
                # if lookups are *NOT* forced then use dnsZoneConfig (else don't)
                Dns_Zone_Config_RR=$(dnsZoneConfig "${Dns_FQDN_RR}" "${Dns_Config_File}" "${Dns_View}")
            fi
        else
            Dns_Zone_Config_RR=$(dnsZoneConfig "${Dns_FQDN_RR}" "${Dns_Config_File}" "${Dns_View}")
        fi
    else
        Dns_Zone_Config_RR=$(dnsZoneConfig "${Dns_FQDN_RR}" "${Dns_Config_File}" "${Dns_View}")
    fi

    if [ ${#Dns_Zone_Config_RR} -gt 0 ]; then
        dnsVerbose "Dns_Zone_Config_RR=${Dns_Zone_Config_RR}" ${Verbose_Level}

        Dns_Zone_Arpa_RR=$(echo "${Dns_Zone_Config_RR}" | awk -F, '{print $2}')
        # remove placeholder
        if [ "${Dns_Zone_Arpa_RR}" == "*" ] || [ "${Dns_Zone_Arpa_RR,,}" == "default" ]; then
            Dns_Zone_Arpa_RR=""
        fi

        Dns_Zone_RR=$(echo "${Dns_Zone_Config_RR}" | awk -F, '{print $1}')
        # remove placeholder
        if [ "${Dns_Zone_RR}" == "*" ] || [ "${Dns_Zone_RR,,}" == "default" ]; then
            Dns_Zone_RR=${Dns_Zone_Arpa_RR}
        fi

        # respect cli option
        if [ ${#Dns_View} -eq 0 ]; then
            Dns_View_RR=$(echo "${Dns_Zone_Config_RR}" | awk -F, '{print $3}')
        fi

        Dns_Server_RR=$(echo "${Dns_Zone_Config_RR}" | awk -F, '{print $4}')

        if [[ "${Dns_Server_RR}" == *";"* ]]; then
            Dns_Server_RR=${Dns_Server_RR%%;*}
        fi

        # respect cli option
        if [ ${#Dns_Server} -gt 0 ]; then
            if [ "${Dns_Server_RR}" != "${Dns_Server}" ]; then
                Warning="Dns_Server for '${Dns_FQDN_RR}'"
                if [ ${#Dns_View} -gt 0 ]; then
                    Warning+=", view '${Dns_View}'"
                fi
                Warning+=" does NOT match what's configured in '${Dns_Config_File}', using '${Dns_Server}' NOT '${Dns_Server_RR}'"
                dnsAlert "${Warning}"
                Dns_Server_RR=${Dns_Server}
            fi
        fi

        # respect cli option
        if [ ${#Dns_Zone_Key} -eq 0 ]; then
            Dns_Zone_Key_RR=$(echo "${Dns_Zone_Config_RR}" | awk -F, '{print $5}')
        fi

    else
        Warning="Dns_Zone for '${Dns_FQDN_RR}'"
        if [ ${#Dns_View} -gt 0 ]; then
            Warning+=", view '${Dns_View}'"
        fi
        Warning+=" NOT configured in '${Dns_Config_File}'"
        dnsAlert "${Warning}"
    fi

    #
    # honor cli options
    #

    if [ ${#Dns_Server} -gt 0 ]; then
        Dns_Server_RR="${Dns_Server}"
        dnsVerbose "(CLI) Dns_Server_RR=${Dns_Server_RR}" ${Verbose_Level}
    fi

    if [ ${#Dns_View} -gt 0 ]; then
        Dns_View_RR="${Dns_View}"
        dnsVerbose "(CLI) Dns_View_RR=${Dns_View_RR}" ${Verbose_Level}
    fi

    if [ ${#Dns_Zone} -gt 0 ]; then
        if [ ${#Dns_Zone_RR} -eq 0 ]; then
            Dns_Zone_RR="${Dns_Zone}"
        else
            # ensure zone is stripped from name and appended
            Dns_Zone_RR=$(echo "${Dns_FQDN_RR}" | sed -e "s#${Dns_Zone}##g")
            Dns_Zone_RR+=".${Dns_Zone}"
            Dns_Zone_RR=${Dns_Zone_RR//../.}
        fi
        dnsVerbose "(CLI) Dns_Zone_RR=${Dns_Zone_RR}" ${Verbose_Level}
    fi

    if [ ${#Dns_Zone_Key} -gt 0 ]; then
        Dns_Zone_Key_RR="${Dns_Zone_Key}"
        dnsVerbose "(CLI) Dns_Zone_Key_RR=${Dns_Zone_Key_RR}" ${Verbose_Level}
    fi

    #
    # validate (initial) dns server ip
    #

    unset -v Dns_Server_Mname_RR
    if [ ${#Dns_Server_RR} -eq 0 ]; then
        # note: this ultimately uses the local resolve.conf & may be incorrect; useful, but something is needed to start!
        Dns_Server_Mname_RR=$(dnsZoneSOA MNAME "${Dns_FQDN_RR}")
        dnsVerbose "Dns_Server_Mname_RR=${Dns_Server_Mname_RR}" ${Verbose_Level}

        Dns_Server_IP_RR=$(dnsLookup value IP "${Dns_Server_Mname_RR}" address)
        if [ ${#Dns_Server_IP_RR} -eq 0 ]; then
            dnsAlert "can't validate authoritative dns server address for '${Dns_FQDN_RR}' MNAME '${Dns_Server_Mname_RR}'; no A or CNAME record for MNAME?"
        fi
    else
        Dns_Server_IP_RR=$(dnsLookup value IP "${Dns_Server_RR}" address)
        if [ ${#Dns_Server_IP_RR} -eq 0 ]; then
            dnsAlert "can't validate authoritative dns server address for '${Dns_FQDN_RR}' server '${Dns_Server_RR}'; dnsLookup failed?"
        fi
    fi

    if [ ${#Dns_Server_IP_RR} -eq 0 ]; then
        Dns_RC=1
        continue
    fi

    Dns_Status_Trace="${Dns_Basename}" && dnsStatus

    #
    # validate dns server port
    #

    if [ ${#Dns_Server_Port} -gt 0 ] && [[ ${Dns_Server_Port} =~ ^[0-9]+$ ]]; then
        # honor cli option
        Dns_Server_Port_RR=${Dns_Server_Port}
    else
        Dns_Server_Port_RR=53
    fi

    if [ ${#Dns_Server_Port_RR} -eq 0 ]; then
        dnsAlert "can't determine dns server port for '${Dns_FQDN_RR}' ${Dns_RR}' record"
        Dns_RC=1
        continue
    fi

    dnsVerbose "Dns_Server_RR=${Dns_Server_RR} (${Dns_Server_IP_RR} port ${Dns_Server_Port_RR}) [INITIAL]" ${Verbose_Level}

    #
    # validate (initial) dns view
    #

    if [ ${#Dns_View_RR} -gt 0 ]; then
        dnsVerbose "Dns_View_RR=${Dns_View_RR} [INITIAL]" ${Verbose_Level}
    fi

    #
    # validate (initial) dns zone keys
    #

    unset -v Dns_Zone_Keys_RR

    # attempt key first
    if [ ${#Dns_Zone_Key_RR} -gt 0 ]; then
        Dns_Zone_Keys_RR=$(dnsZoneKeyfile "${Dns_FQDN_RR}" "" "" "${Dns_Zone_Key_RR}" "")
        if [ ${#Dns_Zone_Keys} -gt 0 ]; then
            dnsVerbose "Dns_Zone_Keys=${Dns_Zone_Keys} [INITIAL] (KEY)" ${Verbose_Level}
        fi
    fi

    # attempt view second
    if [ ${#Dns_Zone_Keys_RR} -eq 0 ] && [ ${#Dns_View_RR} -gt 0 ]; then
        Dns_Zone_Keys_RR=$(dnsZoneKeyfile "${Dns_FQDN_RR}" "" "" "" "${Dns_View_RR}")
        if [ ${#Dns_Zone_Keys} -gt 0 ]; then
            dnsVerbose "Dns_Zone_Keys=${Dns_Zone_Keys} [INITIAL] (VIEW)" ${Verbose_Level}
        fi
    fi

    if [ ${#Dns_Zone_Keys_RR} -gt 0 ]; then
        Dns_Zone_Key_RR=${Dns_Zone_Keys_RR##*,}
        Dns_Zone_Keyfile_RR=${Dns_Zone_Keys_RR%%,*}
    fi

    if [ ${#Dns_Zone_Key_RR} -gt 0 ]; then
        dnsVerbose "Dns_Zone_Key_RR=${Dns_Zone_Key_RR} [INITIAL]" ${Verbose_Level}
    fi

    if [ ${#Dns_Zone_Keyfile_RR} -gt 0 ]; then
        dnsVerbose "Dns_Zone_Keyfile_RR=${Dns_Zone_Keyfile_RR} [INITIAL]" ${Verbose_Level}
    fi

    #
    # validate (final) dns server
    #

    if [ ${#Dns_Server_RR} -eq 0 ] && [ ${#Dns_Server_Mname_RR} -gt 0 ]; then
        Dns_Server_RR=$(dnsZoneSOA MNAME "${Dns_FQDN_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}")
    fi

    Dns_Server_RR=$(echo "${Dns_Server_RR}" | sed -e '/\.*$/s///g')

    if [ ${#Dns_Server_RR} -eq 0 ]; then
        if [ ${#Dns_View_RR} -eq 0 ]; then
            if [ ${#Dns_Zone_Key_RR} -eq 0 ]; then
                dnsAlert "can't validate authoritative dns server for '${Dns_FQDN_RR}' ${Dns_RR} record; no key?"
            else
                dnsAlert "can't validate authoritative dns server for '${Dns_FQDN_RR}' ${Dns_RR} record; using key '${Dns_Zone_Key_RR}'?"
            fi
        else
            if [ ${#Dns_Zone_Key_RR} -eq 0 ]; then
                dnsAlert "can't validate authoritative dns server for '${Dns_FQDN_RR}' ${Dns_RR} record; no key for view '${Dns_View_RR}'?"
            else
                dnsAlert "can't validate authoritative dns server for '${Dns_FQDN_RR}' ${Dns_RR} record; using key '${Dns_Zone_Key_RR}' for view '${Dns_View_RR}'?"
            fi
        fi
        Dns_RC=1
        continue
    fi

    Dns_Status_Trace="${Dns_Basename}" && dnsStatus

    Dns_Server_IP_RR=$(dnsLookup value IP "${Dns_Server_RR}" address)
    if [ ${#Dns_Server_IP_RR} -eq 0 ]; then
        dnsAlert "absolutely can't determine authoritative dns server address for '${Dns_FQDN_RR}' server '${Dns_Server_RR}'; nothing works"
        Dns_RC=1
        continue
    fi

    Dns_Status_Trace="${Dns_Basename}" && dnsStatus

    dnsVerbose "Dns_Server_RR=${Dns_Server_RR} (${Dns_Server_IP_RR} port ${Dns_Server_Port_RR}) [FINAL]" ${Verbose_Level}

    #
    # set (initial) dns zone soa via recurse logic
    #

    Dns_Zone_SOA_RR=$(dnsZoneSOA RECURSE "${Dns_FQDN_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}")

    dnsVerbose "Dns_Zone_SOA_RR=${Dns_Zone_SOA_RR} [INITIAL]" $((${Verbose_Level}))

    #
    # validate (initial) dns arpa zone
    #

    if [ ${#Dns_Zone_Arpa_RR} -eq 0 ]; then
        if [ "${Dns_RR}" == "PTR" ]; then
            Dns_Zone_Arpa_RR=$(dnsZoneConfig "${Dns_Zone_Arpa}" "${Dns_Config_File}" "${Dns_View}" | awk -F, '{print $2}')
            if [ ${#Dns_Zone_Arpa_RR} -eq 0 ]; then
                Dns_Zone_Arpa_RR="${Dns_Zone_Arpa}"
            fi
        else
            Dns_Zone_Arpa_RR="${Dns_Zone_Arpa}"
        fi
    fi

    dnsVerbose "Dns_Zone_Arpa_RR=${Dns_Zone_Arpa_RR} [INITIAL]" $((${Verbose_Level}))

    #
    # validate (final) dns arpa zone
    #

    if [ "${Dns_RR}" == "PTR" ] && [ ${#Dns_Zone_SOA_RR} -gt 0 ]; then
        if [ "${Dns_Zone_Arpa_RR}" != "${Dns_Zone_SOA_RR}" ]; then
            dnsWarning "zone arpa '${Dns_Zone_Arpa_RR}' in ${Dns_Config_Basename} does NOT match, using SOA '${Dns_Zone_SOA_RR}'"
            Dns_Zone_Arpa_RR=${Dns_Zone_SOA_RR}
        fi

        if ! (dnsZoneSOA RNAME "${Dns_Zone_Arpa_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}" &> /dev/null); then
            # it's an (rname).invalid zone; don't even attempt to proceed
            if [ "${Dns_Zone_Arpa_RR}" == "1.0.0.127.in-addr.arpa" ] || [ "${Dns_Zone_Arpa_RR}" == "1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa" ]; then
                dnsWarning "refusing to change zone '${Dns_Zone_Arpa_RR}'"
            else
                dnsAlert "refusing to change zone '${Dns_Zone_Arpa_RR}'; RNAME invalid?"
                Dns_RC=1
            fi
            continue
        fi
    fi

    dnsVerbose "Dns_Zone_Arpa_RR=${Dns_Zone_Arpa_RR} [FINAL]" $((${Verbose_Level}))

    #
    # validate (initial) dns zone
    #

    dnsVerbose "Dns_Zone_RR=${Dns_Zone_RR} [INITIAL]" $((${Verbose_Level}))

    if [ ${#Dns_Zone_RR} -eq 0 ]; then
        Dns_Zone_RR=${Dns_Zone_SOA_RR}
    fi

    #
    # validate (final) dns zone soa via recurse logic
    #

    if [ ${#Dns_Zone_SOA_RR} -eq 0 ]; then
        Dns_Zone_SOA_RR=$(dnsZoneSOA RECURSE "${Dns_FQDN_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}")

        if [ ${#Dns_Zone_SOA_RR} -eq 0 ]; then
            dnsAlert "no SOA for '${Dns_FQDN_RR}'"
            Dns_RC=1
            continue
        fi
    fi

    dnsVerbose "Dns_Zone_SOA_RR=${Dns_Zone_SOA_RR} [FINAL]" $((${Verbose_Level}))

    #
    # validate (final) dns zone
    #

    if [ "${Dns_RR}" != "PTR" ]; then
        if [ "${Dns_Zone_RR}" != "${Dns_Zone_SOA_RR}" ]; then
            dnsWarning "${Dns_Config_Basename} zone '${Dns_Zone_RR}' does NOT match, using SOA '${Dns_Zone_SOA_RR}'"

            Dns_Zone_RR=${Dns_Zone_SOA_RR}
        fi
    fi

    if [ ${#Dns_Zone_RR} -eq 0 ]; then
        dnsAlert "can't determine zone for '${Dns_FQDN_RR}'"
        Dns_RC=1
        continue
    fi

    dnsVerbose "Dns_Zone_RR=${Dns_Zone_RR} [FINAL]" $((${Verbose_Level}))

    #
    # set dns reference (zone)
    #

    if [ "${Dns_RR}" == "PTR" ]; then
        Dns_Zone_Reference_RR="${Dns_Zone_Arpa_RR}"
    else
        Dns_Zone_Reference_RR="${Dns_Zone_RR}"
    fi

    dnsVerbose "Dns_Zone_Reference_RR=${Dns_Zone_Reference_RR}" $((${Verbose_Level}))

    #
    # validate (final) dns zone keys
    #

    unset -v Dns_Zone_Keys_RR

    Dns_Zone_Keys_RR=$(dnsZoneKeyfile "${Dns_Zone_Reference_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_View_RR}")

    if [ ${#Dns_Zone_Keys_RR} -gt 0 ]; then
        Dns_Zone_Key_RR=${Dns_Zone_Keys_RR##*,}
        Dns_Zone_Keyfile_RR=${Dns_Zone_Keys_RR%%,*}
    fi

    if [ "${Dns_Action}" != "lookup" ]; then
        if [ ${#Dns_Zone_Key_RR} -gt 0 ]; then
            dnsVerbose "Dns_Zone_Key_RR=${Dns_Zone_Key_RR} [FINAL]" ${Verbose_Level}
        else
            dnsAlert "can't validate zone key for '${Dns_Zone_Reference_RR}'"
            Dns_RC=1
            continue
        fi

        if [ ${#Dns_Zone_Keyfile_RR} -gt 0 ]; then
            dnsVerbose "Dns_Zone_Keyfile_RR=${Dns_Zone_Keyfile_RR} [FINAL]" ${Verbose_Level}
        else
            dnsAlert "can't validate zone keyfile for '${Dns_Zone_Reference_RR}'"
            Dns_RC=1
            continue
        fi
    fi

    #
    # validate dns data
    #

    if [ ${#Dns_Data_RR} -gt 0 ]; then
        if [ "${Dns_RR}" == "CNAME" ] || [ "${Dns_RR}" == "MX" ] || [ "${Dns_RR}" == "NS" ]; then
            # ensure same zone is stripped from name and proper zone appended
            Dns_Data_RR=${Dns_Data_RR//+(.)/.}
            if [ "${Dns_Data_RR:${#Dns_Data_RR}-1:1}" == "." ]; then
                Dns_Data_RR=${Dns_Data_RR::-1}
            fi
            if [ "${Dns_Data_RR:0:1}" == "." ]; then
                Dns_Data_RR="${Dns_Data_RR:1:${#Dns_Data_RR}-1}"
            fi
            if [[ "${Dns_Data_RR}" != *"."* ]]; then
                Dns_Data_RR+=".${Dns_Zone_RR}"
            fi
        fi
    fi

    dnsVerbose "Dns_Data_RR=${Dns_Data_RR} [FINAL]" ${Verbose_Level}

    #
    # set lookup varables
    #

    unset -v Dns_Lookup_FQDN_RR Dns_Lookup_Data_RR Dns_Lookup_Value_RR

    Dns_Lookup_FQDN_RR="${Dns_FQDN_RR}"
    Dns_Lookup_Data_RR="${Dns_Data_RR}"

    #
    # get current record data
    #

    Dns_Lookup_Value_RR=$(dnsLookup value "${Dns_RR}" "${Dns_Lookup_FQDN_RR}" "${Dns_Lookup_Data_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}")

    Dns_Status_Trace="${Dns_Basename}" && dnsStatus

    dnsVerbose "Dns_Lookup_FQDN_RR=${Dns_Lookup_FQDN_RR}" ${Verbose_Level}
    dnsVerbose "Dns_Lookup_Data_RR=${Dns_Lookup_Data_RR}" ${Verbose_Level}
    dnsVerbose "Dns_Lookup_Value_RR=${Dns_Lookup_Value_RR}" ${Verbose_Level}

    #
    # if requested, only do lookup
    #

    if [ "${Dns_Action}" == "lookup" ]; then
        Dns_Lookup_Value_RR=$(dnsLookup value "${Dns_RR}" "${Dns_Lookup_FQDN_RR}" "${Dns_Lookup_Data_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}")
        if [ $? -ne 0 ]; then
            Dns_RC=1
        fi
        echo "${Dns_Lookup_FQDN_RR} ${Dns_RR} = ${Dns_Lookup_Value_RR}"
        continue
    fi

    #
    # final safety checks
    #

    if [ "$Dns_Action" == "delete" ]; then
        # todo: test
        if [ "${Dns_FQDN_RR}" == "${Dns_Data_RR}" ]; then
            Dns_Data_RR=""
        fi
    else
        if [ "${Dns_FQDN_RR}" == "${Dns_Data_RR}" ]; then
            dnsAlert "invalid dns data '${Dns_Data_RR}' equals FQDN '${Dns_FQDN_RR}'; refused"
            Dns_RC=1
            continue
        fi
    fi

    if [ "${Dns_RR}" == "A" ] || [ "${Dns_RR}" == "AAAA" ]; then
        # forcing will work, here. dnsUpdate will remove matching CNAMEs (when forced)
        if [ ${#Dns_Lookup_Value_RR} -eq 0 ]; then
            if [ ${Dns_Force_Flag} -ne 0 ]; then
                Dns_Lookup_Value_RR=$(dnsLookup value "CNAME" "${Dns_Lookup_FQDN_RR}" "${Dns_Lookup_Data_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}")
                if [ ${#Dns_Lookup_Value_RR} -gt 0 ]; then
                    dnsAlert "CNAME found for '${Dns_FQDN_RR}'; DATA '${Dns_Lookup_Value_RR}'"
                    Dns_RC=1
                    continue
                fi
            fi
        fi
    fi

    if [ "${Dns_RR}" == "CNAME" ]; then
        # forcing wont work, here. nsupdate will fail when trying to add a cname when an A record already exists
        #if [ "${Dns_Action}" != "delete" ]; then
        if [ ${Dns_Force_Flag} -ne 0 ] && [ "${Dns_Action}" != "delete" ]; then
            if (dnsLookup value "A" "${Dns_Lookup_FQDN_RR}" "${Dns_Lookup_Data_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}" &> /dev/null); then
                dnsAlert "conflicting A record for '${Dns_FQDN_RR}' exists"
                Dns_RC=1
                continue
            else
                if (dnsLookup value "AAAA" "${Dns_Lookup_FQDN_RR}" "${Dns_Lookup_Data_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}" &> /dev/null); then
                    dnsAlert "conflicting AAAA record for '${Dns_FQDN_RR}' exists"
                    Dns_RC=1
                    continue
                fi
            fi
        fi

        # forcing wont work, here. nsupdate will fail when trying to add a cname as the soa
        if [ "${Dns_Action}" != "delete" ]; then
            if [ "${Dns_FQDN_RR}" == "${Dns_Zone_SOA_RR}" ]; then
                dnsAlert "authoritative zone '${Dns_Zone_SOA_RR}' can't be a CNAME"
                Dns_RC=1
                continue
            fi
        fi

        # forcing will work, here. nsupdate will add a CNAME record without an address record
        if [ ${Dns_Force_Flag} -ne 0 ] && [ "${Dns_Action}" != "delete" ]; then
            if ! (dnsLookup value "IP" "${Dns_Lookup_Data_RR}" "${Dns_Lookup_Data_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}" &> /dev/null); then
                dnsAlert "IP address record for '${Dns_Data_RR}' not found for ${Dns_RR} '${Dns_FQDN_RR}'"
                Dns_RC=1
                continue
            fi
        fi
    fi

    if [ "${Dns_RR}" == "MX" ]; then

        if [ ${Dns_Force_Flag} -ne 0 ]; then
            # forcing will not work, here. nsupdate will refuse to add an MX record that's a CNAME
            if (dnsLookup value "CNAME" "${Dns_Lookup_Data_RR}" "${Dns_Lookup_Data_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}" &> /dev/null); then
                dnsAlert "CNAME '${Dns_Lookup_Data_RR}' found for ${Dns_RR} '${Dns_FQDN_RR}'; ${Dns_RR} can't be a CNAME"
                Dns_RC=1
                continue
            fi

        # force?
        if ! (dnsLookup value "A" "${Dns_Lookup_Data_RR}" "${Dns_Lookup_Data_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}" &> /dev/null); then
            if ! (dnsLookup value "AAAA" "${Dns_Lookup_Data_RR}" "${Dns_Lookup_Data_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}" &> /dev/null); then
                dnsAlert "IP address record for '${Dns_FQDN_RR}' not found for ${Dns_RR} '${Dns_Data_RR}'"
                Dns_RC=1
                continue
            fi
        fi
    fi

fi

if [ "${Dns_RR}" == "NS" ]; then

        # forcing will not work, here. nsupdate will refuse to add an NS record that's a CNAME
        if (dnsLookup value "CNAME" "${Dns_Lookup_Data_RR}" "${Dns_Lookup_Data_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}" &> /dev/null); then
            dnsAlert "CNAME '${Dns_Lookup_Data_RR}' found for ${Dns_RR} '${Dns_FQDN_RR}'; ${Dns_RR} can't be a CNAME"
            Dns_RC=1
            continue
        fi

        # forcing will not work, here. nsupdate will refuse to add an NS record without an address record
        if ! (dnsLookup value "A" "${Dns_Lookup_Data_RR}" "${Dns_Lookup_Data_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}" &> /dev/null); then
            if ! (dnsLookup value "AAAA" "${Dns_Lookup_Data_RR}" "${Dns_Lookup_Data_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}" &> /dev/null); then
                dnsAlert "IP address record not found for ${Dns_RR} '${Dns_Data_RR}'; add an A record first (to delete an orphaned NS record)"
                Dns_RC=1
                continue
            fi
        fi

    fi

    if [ "${Dns_RR}" == "TXT" ]; then
        # forcing will work, here. nsupdate will add a CNAME record without an address record
        if [ ${Dns_Force_Flag} -ne 0 ]; then
            if ! (dnsLookup value "A" "${Dns_Lookup_FQDN_RR}" "${Dns_Lookup_Data_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}" &> /dev/null); then
                if ! (dnsLookup value "AAAA" "${Dns_Lookup_FQDN_RR}" "${Dns_Lookup_Data_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}" &> /dev/null); then
                    if ! (dnsLookup value "CNAME" "${Dns_Lookup_FQDN_RR}" "${Dns_Lookup_Data_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}" &> /dev/null); then
                        dnsAlert "IP address or CNAME record for '${Dns_FQDN_RR}' not found for ${Dns_RR} '${Dns_Data_RR}'"
                        Dns_RC=1
                        continue
                    fi
                fi
            fi
        fi
    fi

    #
    # preset output variables
    #

    Dns_Status_Trace="${Dns_Basename}" && dnsStatus

    Dns_Status_RR=${Dns_Status}

    #Dns_Status_RR+=" CURRENT ${Dns_Lookup_FQDN_RR} ${Dns_RR} = ${Dns_Lookup_Value_RR}"
    Dns_Status_RR+=" = ${Dns_Lookup_Value_RR}"

    #
    # set default actions
    #

    if [ ${Dns_Force_Flag} -eq 0 ] || [ "${Dns_Action}" == "check" ] || [ "${Dns_Action}" == "update" ]; then
        Dns_Add_RR=1
        Dns_Delete_RR=1
        Dns_Update_RR=0
    else
        if [ "${Dns_Action}" == "add" ]; then
            Dns_Add_RR=0
        else
            Dns_Add_RR=1
        fi

        if [ "${Dns_Action}" == "delete" ]; then
            Dns_Delete_RR=0
        else
            Dns_Delete_RR=1
        fi

        Dns_Update_RR=1
    fi

    #
    # validate action
    #

    unset -v Dns_OK
    Dns_OK=0 # true

    if dnsLookup exact "${Dns_RR}" "${Dns_Lookup_FQDN_RR}" "${Dns_Lookup_Data_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}"; then
        if [ ${Dns_Force_Flag} -eq 0 ]; then
            dnsVerbose "${Dns_Status_RR} [EXACT; FORCE]" ${Verbose_Level}
            if [ "${Dns_Action}" == "delete" ]; then
                Dns_Delete_RR=0
            else
                Dns_Add_RR=0
                Dns_Delete_RR=0
            fi
        else
            if [ ${Dns_Add_RR} -eq 0 ]; then
                dnsVerbose "${Dns_Status_RR} [EXACT; ADD]" ${Verbose_Level}
                Dns_Add_RR=1
            else
                if [ ${Dns_Delete_RR} -eq 0 ]; then
                    dnsVerbose "${Dns_Status_RR} [EXACT; DELETE]" ${Verbose_Level}
                else
                    if [ ${Dns_Update_RR} -eq 0 ]; then
                        dnsVerbose "${Dns_Status_RR} [EXACT; UPDATE]" ${Verbose_Level}
                        Dns_Add_RR=0
                        Dns_Delete_RR=0
                    fi
                fi
            fi
        fi
    else
        if dnsLookup match "${Dns_RR}" "${Dns_Lookup_FQDN_RR}" "${Dns_Lookup_Data_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}"; then
            if [ ${Dns_Force_Flag} -eq 0 ]; then
                dnsVerbose "${Dns_Status_RR} [MATCH; FORCE]" ${Verbose_Level}
                if [ "${Dns_Action}" == "delete" ]; then
                    Dns_Delete_RR=0
                else
                    Dns_Add_RR=0
                    Dns_Delete_RR=0
                fi
            else
                if [ ${Dns_Add_RR} -eq 0 ]; then
                    dnsVerbose "${Dns_Status_RR} [MATCH; ADD]" ${Verbose_Level}
                    Dns_Add_RR=1
                else
                    if [ ${Dns_Delete_RR} -eq 0 ]; then
                        dnsVerbose "${Dns_Status_RR} [MATCH; DELETE]" ${Verbose_Level}
                    else
                        if [ ${Dns_Update_RR} -eq 0 ]; then
                            dnsVerbose "${Dns_Status_RR} [MATCH; UPDATE]" ${Verbose_Level}
                        fi
                    fi
                fi
            fi
        else
            if dnsLookup exist "${Dns_RR}" "${Dns_Lookup_FQDN_RR}" "${Dns_Lookup_Data_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}"; then
                if [ ${Dns_Force_Flag} -eq 0 ]; then
                    dnsVerbose "${Dns_Status_RR} [MISMATCH; FORCE]" ${Verbose_Level}
                    if [ "${Dns_Action}" == "delete" ]; then
                        Dns_Delete_RR=0
                    else
                        Dns_Add_RR=0
                        Dns_Delete_RR=0
                    fi
                else
                    if [ ${Dns_Add_RR} -eq 0 ]; then
                        dnsVerbose "${Dns_Status_RR} [MISMATCH; ADD]" ${Verbose_Level}
                        if [ ${Dns_Multiple_Flag} -ne 0 ]; then
                            Dns_Add_RR=1
                            Dns_OK=1
                        fi
                    else
                        if [ ${Dns_Delete_RR} -eq 0 ]; then
                            dnsVerbose "${Dns_Status_RR} [MISMATCH; DELETE]" ${Verbose_Level}
                            Dns_Delete_RR=1
                            if [ "${Dns_Action}" == "delete" ]; then
                                Dns_OK=0
                            else
                                Dns_OK=1
                            fi
                        else
                            if [ ${Dns_Update_RR} -eq 0 ]; then
                                dnsVerbose "${Dns_Status_RR} [MISMATCH; UPDATE]" ${Verbose_Level}
                                Dns_Add_RR=0
                                Dns_Delete_RR=0
                            fi
                        fi
                    fi
                fi
            else
                if [ ${Dns_Force_Flag} -eq 0 ]; then
                    dnsVerbose "${Dns_Status_RR} [MISSING; FORCE]" ${Verbose_Level}
                    if [ "${Dns_Action}" == "add" ] || [ "${Dns_Action}" == "update" ]; then
                        Dns_Add_RR=0
                        Dns_Delete_RR=0
                    fi
                    if [ "${Dns_Action}" == "delete" ] || [ "${Dns_Action}" == "update" ]; then
                        Dns_Delete_RR=0
                    fi
                else
                    if [ ${Dns_Add_RR} -eq 0 ]; then
                        dnsVerbose "${Dns_Status_RR} [MISSING; ADD]" ${Verbose_Level}
                    else
                        if [ ${Dns_Delete_RR} -eq 0 ]; then
                            dnsVerbose "${Dns_Status_RR} [MISSING; DELETE]" ${Verbose_Level}
                            Dns_Delete_RR=1
                            Dns_OK=1
                        else
                            if [ ${Dns_Update_RR} -eq 0 ]; then
                                dnsVerbose "${Dns_Status_RR} [MISSING; UPDATE]" ${Verbose_Level}
                                Dns_Add_RR=0
                            fi
                        fi
                    fi
                fi
            fi
        fi
    fi

    Dns_Status_Trace="${Dns_Basename}" && dnsStatus

    dnsVerbose "Dns_Update_RR=${Dns_Update_RR}" ${Verbose_Level}
    dnsVerbose "Dns_Delete_RR=${Dns_Delete_RR}" ${Verbose_Level}
    dnsVerbose "Dns_Add_RR=${Dns_Add_RR}" ${Verbose_Level}

    Dns_Action_RRS=()

    if [ ${Dns_Delete_RR} -eq 1 ] && [ ${Dns_Add_RR} -eq 1 ]; then
        if [ "${Dns_Action}" == "add" ]; then
            if [ ${#Dns_Lookup_Value_RR} -eq 0 ]; then
                Dns_OK=0
            else
                Dns_Status_RR+=" [DO NOT ADD]"
            fi
        else
            if [ "${Dns_Action}" == "delete" ]; then
                Dns_Status_RR+=" [DO NOT DELETE]"
            else
                if [ "${Dns_Action}" == "update" ]; then
                    Dns_Status_RR+=" [DO NOT UPDATE]"
                fi
            fi
        fi

        if [ ${Dns_OK} -eq 0 ]; then
            Dns_Status_RR="[OK]:${Dns_Status_RR}"
        else
            Dns_Status_RR="[NOTICE]:${Dns_Status_RR}"
        fi
    else
        if [ ${Dns_Delete_RR} -eq 0 ]; then
            Dns_Action_RRS+=(delete)
            Dns_Status_RR+=" *DELETE REQUIRED*"
        fi

        if [ ${Dns_Add_RR} -eq 0 ]; then
            Dns_Action_RRS+=(add)
            Dns_Status_RR+=" *ADD REQUIRED*"
        fi

        Dns_Status_RR="[INFO]:[LOOKUP]:${Dns_Status_RR}"
    fi

    dnsEcho "${Dns_Status_RR}"

    if [ "${Dns_Action}" == "check" ] || [ "${Dns_Action}" == "lookup" ]; then
        continue
    fi

    if [ ${Dns_Delete_RR} -eq 1 ] && [ ${Dns_Add_RR} -eq 1 ]; then
        continue
    fi

    #
    # validation complete; thaw zone, do updates, sync, & clean
    #

    if [ ${Dns_Rndc_Flag} -eq 0 ]; then
        if [ "${Dns_Server_IP_RR}" == "127.0.0.1" ] || [ "${Dns_Server_IP_RR}" == "::1" ]; then
            rndc thaw &> /dev/null
            if [ $? -ne 0 ]; then
                dnsAlert "rndc thaw [FAILED]"
                aborting
            fi
        fi
    fi

    for Dns_Action_RR in "${Dns_Action_RRS[@]}"; do
        Dns_Status_Trace="${Dns_Basename}" && dnsStatus

        if dnsUpdate "${Dns_Action_RR}" "${Dns_RR}" "${Dns_Lookup_FQDN_RR}" "${Dns_Lookup_Data_RR}" "${Dns_Data_Class}" "${Dns_Data_Port}" "${Dns_Data_Priority}" "${Dns_Data_TTL}" "${Dns_Data_Weight}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Reference_RR}" "${Dns_Zone_Arpa_RR}" "${Dns_Zone_SOA_RR}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}"; then
            Dns_Status_Trace="${Dns_Basename}" && dnsStatus
            Dns_Lookup_Value_RR=$(dnsLookup value "${Dns_RR}" "${Dns_Lookup_FQDN_RR}" "${Dns_Lookup_Data_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}")
            if [ ${#Dns_Lookup_Value_RR} -eq 0 ]; then
                Dns_Lookup_Value_RR="DOES NOT EXIST"
            fi
            Dns_Status_RR=${Dns_Status}
            #Dns_Status_RR+=" SUCCESS ${Dns_Lookup_FQDN_RR} ${Dns_RR} = ${Dns_Lookup_Value_RR}"
            Dns_Status_RR+=" = ${Dns_Lookup_Value_RR}"
            Dns_Status_RR="[OK]:[SUCCESS]:${Dns_Status_RR}" # huh?
            dnsEcho "${Dns_Status_RR}"

        else
            Dns_Status_Trace="${Dns_Basename}" && dnsStatus
            Dns_Lookup_Value_RR=$(dnsLookup value "${Dns_RR}" "${Dns_Lookup_FQDN_RR}" "${Dns_Lookup_Data_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}")
            if [ ${#Dns_Lookup_Value_RR} -eq 0 ]; then
                Dns_Lookup_Value_RR="DOES NOT EXIST"
            fi
            Dns_Status_RR=${Dns_Status}
            #Dns_Status_RR+=" AFTER ${Dns_Lookup_FQDN_RR} ${Dns_RR} = ${Dns_Lookup_Value_RR}"
            Dns_Status_RR+=" = ${Dns_Lookup_Value_RR}"
            Dns_Status_RR="[ERROR]:[RESULT]:${Dns_Status_RR}"
            dnsEcho "${Dns_Status_RR}"

            dnsAlert "[FAILED] ${0} ${Arguments}"
        fi
    done

    if [ ${Dns_Rndc_Flag} -eq 0 ]; then
        if [ -r "${Dns_Dir}/etc/named.shared.masters.conf" ]; then
            grep -q "${Dns_Server_IP_RR};" "${Dns_Dir}/etc/named.shared.masters.conf"
            if [ $? -eq 0 ]; then
                rndc sync -clean &> /dev/null
                if [ $? -ne 0 ]; then
                    dnsAlert "rndc sync -clean [FAILED]"
                fi
            fi
        fi
    fi

    if [ ${Dns_All_Flag} -ne 0 ]; then
        break
    fi

done

unset -v Dns_Status Dns_Status_RR Dns_Status_Trace

#
# End dns
#

if [ ${Dns_RC} -ne 0 ]; then
    dnsAlert "'${0} ${Arguments}' [FAILED]"
fi

if [ "${BASH_SOURCE}" != "${0}" ]; then
    return ${Dns_RC}
else
    exit ${Dns_RC}
fi
