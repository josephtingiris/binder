#!/bin/bash

# add/check/delete/update dns records (proof of concept; simplify administration of a common implementation of bind)

# 20181218, jtingiris

#
# Globals
#

PATH=/bin:/usr/bin:/sbin:/usr/sbin

Verbose_Level=18 # <10 for debugging
if [ ${Verbose_Level} -eq 0 ]; then
    Verbose=""
fi

if [ ${#Verbose} -eq 0 ]; then
    declare -i Verbose=4 # WARNING
else
    if [ ${#VERBOSE} -gt 0 ]; then
        if [[ ${VERBOSE} =~ ^[0-9]+$ ]]; then
            Verbose=${VERBOSE}
        fi
    fi
fi
Verbose_Level_Prefix=on

Default_Data_Priority=10
Default_Data_TTL=60

# supported actions
Dns_Actions=()
Dns_Actions+=(add)
Dns_Actions+=(check)
Dns_Actions+=(delete)
Dns_Actions+=(update)

# any machine using this script requires these ...
Dns_Dependencies=()
Dns_Dependencies+=(curl)
Dns_Dependencies+=(dig)
Dns_Dependencies+=(egrep)
Dns_Dependencies+=(find)
Dns_Dependencies+=(getent)
Dns_Dependencies+=(host)
Dns_Dependencies+=(grep)
Dns_Dependencies+=(nslookup)
Dns_Dependencies+=(nsupdate)
Dns_Dependencies+=(sed)

Dns_Echo_Pad_Left=11
Dns_Echo_Pad_Right=95

# supported records; see nsupdate -T (on recent versions of nsupdate)
Dns_Records=()
Dns_Records+=(A)
Dns_Records+=(AAAA)
#Dns_Records+=(MX)
#Dns_Records+=(NS)
Dns_Records+=(PTR)

Host_Args="-W 2"
Nsupdate_Args="-t 3 -v"

# feature flags

All_Flag=1 # false
Force_Flag=1 # false
if [ ${Verbose_Level} -eq 0 ]; then
    Mail_Flag=0 # true
else
    Mail_Flag=1 # false
fi
Rndc_Flag=1 # false

#
# Functions
#


# standard output an 'aborting' message and exit with a non-zero return code
function aborting() {
    local abort_message="${@}"
    printf "\naborting, %s\n\n" "${abort_message}"

    if [ "${BASH_SOURCE}" != "${0}" ]; then
        return 2
    else
        exit 2
    fi
}


# output an alert message and send an alert email
function dnsAlert() {
    local alert_message=$@

    alert_message="!! ALERT !! : ${alert_message[@]}"
    verbose "${alert_message}"

    if [ ${Mail_Flag} -eq 0 ]; then
        local alert_mail mailx
        mailx=$(type -P mailx)
        if [ ${#mailx} -gt 0 ] && [ ! -d ${mailx} ] && [ -x ${mailx} ] && [ ${#Dns_Admin_Email} -gt 0 ]; then
            alert_mail="${alert_message}\n\n"
            alert_mail+="exec = $0 ${Arguments}\n\n"
            alert_mail+="date = $(date)\n"
            alert_mail+="host = $(hostname)\n"
            alert_mail+="user = $(logname)\n"
            printf "${alert_mail}" | ${mailx} -S "from=DNS <noreply@clacorp.com>" -s "${alert_message}" ${Dns_Admin_Email}
        fi
    fi
}


# standard output config key value from dns.conf
function dnsBackup() {
    local backup_from="${1}"
    local backup_to="${2}"

    local verbose_level=18

    if [ ! -r "${backup_from}" ]; then
        dnsAlert "backup from '${backup_from}' failed; file not readable"
        return 1
    fi

    set -o pipefail

    if [ ${#backup_to} -eq 0 ]; then
        backup_to=${Dns_Dir}/backup$(echo "${backup_from}" | sed "s#${Dns_Dir}##g")
        if [ $? -ne 0 ]; then
            dnsAlert "backup from '${backup_from}' failed; failed to sed '${Dns_Dir}'"
            aborting
        fi
    fi
    backup_to+="-$(date +%Y%m%d)"

    local backup_count=1
    while [ -a "${backup_to}.${backup_count}" ]; do
        let backup_count=${backup_count}+1
    done

    if [ -a "${backup_to}.$((backup_count-1))" ] && [ ! -d "${backup_to}.$((backup_count-1))" ]; then
        diff -q "${backup_from}" "${backup_to}.$((backup_count-1))" &> /dev/null
        if [ $? -eq 0 ]; then
            # no need to backup; files are identical
            return 2
        fi
    fi

    backup_to+=".${backup_count}"

    verbose "${FUNCNAME} backup_from=${backup_from}" ${verbose_level}
    verbose "${FUNCNAME} backup_to=${backup_to}" ${verbose_level}

    local backup_dir
    if [ ! -d "${backup_from}" ]; then
        backup_dir="$(dirname "${backup_to}")"
    else
        backup_dir="${backup_to}"
    fi

    if [ ! -d "${backup_dir}" ]; then
        mkdir -p "${backup_dir}"
        if [ $? -ne 0 ]; then
            aborting "failed to mkdir -p '${backup_dir}'"
        fi
    fi

    if [ ! -w "${backup_dir}" ]; then
        aborting "'${backup_dir}' directory not writable"
    fi

    verbose "${FUNCNAME} backup_dir=${backup_dir}" ${verbose_level}

    if [ -d "${backup_from}" ]; then
        cp -rp "${backup_from}/" "${backup_to}"
        if [ $? -eq 0 ]; then
            return 0
        else
            aborting "cp -rp '${backup_from}/' '${backup_to}/' failed"
        fi
    else
        cp -p "${backup_from}" "${backup_to}"
        if [ $? -eq 0 ]; then
            return 0
        else
            aborting "cp -p '${backup_from}' '${backup_to}/' failed"
        fi
    fi

    aborting "${FUNCNAME} dead code; bug"
}


# standard output config key value from dns.conf
function dnsConfig() {
    local dns_config_key="${1}"
    local dns_config_file="${2}"

    local verbose_level=18

    if [ ${#dns_config_key} -eq 0 ]; then
        return 1
    fi

    if [ ${#dns_config_file} -eq 0 ]; then
        dns_config_file="${Dns_Config_File}"
    fi

    if [ ${#dns_config_file} -eq 0 ]; then
        dnsAlert "${FUNCNAME} dns configuration file missing; value is empty"
        aborting
    else
        if [ ! -r "${dns_config_file}" ]; then
            dnsAlert "${FUNCNAME} dns configuration file missing; '${dns_config_file}' file not readable"
            aborting
        fi
    fi

    set -o pipefail

    # strip spaces!
    sed -e '/[[:space:]]/s///g' "${dns_config_file}" 2> /dev/null | egrep -e "^${dns_config_key}=" | head -1 | awk -F\# '{print $1}' | sed -nEe 's#.*=(.*).*#\1#p' 2> /dev/null

    # return pipefail result code
    return $?

}


# standard output with consistency
function dnsEcho() {
    local echo_message="${@}"

    if [[ "${echo_message^^}" == *":"* ]]; then
        v1="${echo_message%%:*}"
        v1="${v1#"${v1%%[![:space:]]*}"}"
        v1="${v1%"${v1##*[![:space:]]}"}"
        v2="${echo_message#*:}"
        v2="${v2#"${v2%%[![:space:]]*}"}"
        v2="${v2%"${v2##*[![:space:]]}"}"
        printf -v echo_message "%-${Dns_Echo_Pad_Left}b : %b" "${v1}" "${v2}"
        unset v1 v2
    fi

    if [[ "${echo_message^^}" == *"="* ]]; then
        v1="${echo_message%%=*}"
        v1="${v1#"${v1%%[![:space:]]*}"}"
        v1="${v1%"${v1##*[![:space:]]}"}"
        v2="${echo_message#*=}"
        v2="${v2#"${v2%%[![:space:]]*}"}"
        v2="${v2%"${v2##*[![:space:]]}"}"
        printf -v echo_message "%-${Dns_Echo_Pad_Right}b = %b" "${v1}" "${v2}"
        unset v1 v2
    fi

    if [ "${Dns_Date}" == "0" ]; then
        echo_message="[$(date +%F\ %R:%S)] ${echo_message}"
    fi

    printf "%b\n" "${echo_message}"
}

# return true if dns record data matches dig record data
function dnsLookup() {
    local -l dns_lookup_action="${1:0:5}"
    local -u dns_record="${2}"
    local -l dns_fqdn="${3}"
    local -l dns_data="${4}"
    local -l dns_server="${5}"
    local -i dns_server_port="${6}"
    local dns_zone_key="${7}"
    local dns_zone_keyfile="${8}"

    local verbose_level=18

    if [ ${#dns_lookup_action} -eq 0 ]; then
        dnsAlert "${FUNCNAME} dns_lookup_action is empty"
        return 1
    fi

    if [ "${dns_lookup_action}" != "exist" ] && [ "${dns_lookup_action}" != "match" ] && [ "${dns_lookup_action}" != "value" ]; then
        dnsAlert "${FUNCNAME} dns_lookup_action '${dns_lookup_action}' is invalid"
        return 1
    fi

    if [ ${#dns_record} -eq 0 ]; then
        dnsAlert "${FUNCNAME} dns_record is empty"
        return 1
    fi

    if [ ${#dns_fqdn} -eq 0 ]; then
        dnsAlert "${FUNCNAME} dns_fqdn is empty"
        return 1
    fi

    if [ ${#dns_data} -eq 0 ]; then
        dnsAlert "${FUNCNAME} dns_data is empty"
        return 1
    fi

    if [ ${#dns_server} -eq 0 ]; then
        dnsAlert "${FUNCNAME} dns_server is empty"
        return 1
    fi

    if [ ${#dns_server_port} -eq 0 ] || [[ ! ${dns_server_port} =~ ^[0-9]+$ ]]; then
        dnsAlert "${FUNCNAME} dns_server_port is empty"
        return 1
    fi

    verbose "${FUNCNAME} dns_lookup_action=${dns_lookup_action}" ${verbose_level}
    verbose "${FUNCNAME} dns_record=${dns_record}" ${verbose_level}
    verbose "${FUNCNAME} dns_fqdn=${dns_fqdn}" ${verbose_level}
    verbose "${FUNCNAME} dns_server=${dns_server} ${dns_server_port}" ${verbose_level}

    verbose "${FUNCNAME} dns_zone_key=${dns_zone_key}" ${verbose_level}
    verbose "${FUNCNAME} dns_zone_keyfile=${dns_zone_keyfile}" ${verbose_level}

    local dns_reference dns_result
    dns_reference="${dns_fqdn}"
    dns_result="${dns_data}"

    verbose "${FUNCNAME} dns_reference=${dns_reference}" ${verbose_level}
    verbose "${FUNCNAME} dns_result=${dns_result}" ${verbose_level}

    local dig_args

    dig_args=""
    dig_args+="@${dns_server}"
    if [ -r "${dns_zone_keyfile}" ]; then
        dig_args+=" -k ${dns_zone_keyfile}"
    fi
    dig_args+=" -p ${dns_server_port}"
    if [ ${#Dns_Record_IP_Family} -gt 0 ]; then
        dig_args+=" -${Dns_Record_IP_Family}"
    fi
    dig_args+=" -q ${dns_reference}"
    dig_args+=" -t ${dns_record}"
    dig_args+=" +answer"
    dig_args+=" +nocl"
    dig_args+=" +nocmd"
    dig_args+=" +nocomments"
    dig_args+=" +nodnssec"
    dig_args+=" +noidentify"
    dig_args+=" +nomultiline"
    dig_args+=" +noquestion"
    dig_args+=" +norrcomments"
    dig_args+=" +nosearch"
    dig_args+=" +nostats"
    dig_args+=" +nottlid"
    if [ "${dns_record}" == "SOA" ]; then
        dig_args+=" +onesoa"
    fi
    dig_args+=" +short"
    #dig_args+=" +tcp"
    dig_args+=" +retry=1" # retry
    dig_args+=" +time=3" # timeout

    local dns_lookup_rc dns_lookup_result dns_lookup_results

    verbose "${FUNCNAME} dig_args=${dig_args}" ${verbose_level} #3 # todo; remove
    #if [ "${dns_record}" == "SOA" ]; then
    dns_lookup_results=($(dig ${dig_args} 2> /dev/null | awk '{print $1}' | sed -e '/\.*$/s///g'))
    #else
    #dns_lookup_results=($(dig ${dig_args} 2> /dev/null))
    #fi

    if [ ${#dns_lookup_results} -eq 0 ]; then
        dns_lookup_rc=1
    else
        dns_lookup_rc=0
    fi

    verbose "${FUNCNAME} dns_lookup_results=${dns_lookup_results[@]} (${dns_lookup_rc})" ${verbose_level} #4 # todo; remove

    if [ "${dns_lookup_action}" == "exist" ]; then
        verbose "${FUNCNAME} dns_lookup_rc=${dns_lookup_rc} ${dns_fqdn} ${dns_record}" ${verbose_level}
        return ${dns_lookup_rc}
    fi

    if [ "${dns_lookup_action}" == "match" ]; then
        local match_rc=1 # false
        if [ ${#dns_lookup_results} -gt 0 ]; then
            for dns_lookup_result in "${dns_lookup_results[@]}"; do
                verbose "${FUNCNAME} dns_lookup_result=${dns_lookup_result} (${dns_result}) [1]" ${verbose_level}
                if [ "${dns_lookup_result}" == "${dns_result}" ]; then
                    match_rc=0
                    break
                fi
            done
        fi
        verbose "${FUNCNAME} match_rc=${match_rc} ${dns_fqdn} ${dns_record}" ${verbose_level}
        return ${match_rc}
    fi

    if [ "${dns_lookup_action}" == "value" ]; then
        local value_rc=1 # false
        if [ ${#dns_lookup_results} -gt 0 ]; then
            for dns_lookup_result in "${dns_lookup_results[@]}"; do
                echo ${dns_lookup_result}
                value_rc=0
            done
        fi
        return ${value_rc}
    fi

    return 1
}

# action dns resource record
function dnsRR() {
    local -l dns_action="${1}"
    local -u dns_record="${2}"
    local -l dns_fqdn="${3}"
    local -l dns_data="${4}"
    local -i dns_data_priority="${5}"
    local -i dns_data_ttl="${6}"
    local -l dns_server="${7}"
    local -i dns_server_port="${8}"
    local -l dns_zone="${9}"
    local -l dns_zone_arpa="${10}"
    local dns_zone_key="${11}"
    local dns_zone_keyfile="${12}"

    local verbose_level=18

    if [ ${#dns_action} -eq 0 ]; then
        dnsAlert "${FUNCNAME} dns_action is empty"
        return 1
    fi
    verbose "${FUNCNAME} dns_action=${dns_action}" ${verbose_level}

    if [ ${#dns_record} -eq 0 ]; then
        dnsAlert "${FUNCNAME} dns_record is empty"
        return 1
    fi
    verbose "${FUNCNAME} dns_record=${dns_record}" ${verbose_level}

    if [ ${#dns_fqdn} -eq 0 ]; then
        dnsAlert "${FUNCNAME} dns_fqdn is empty"
        return 1
    fi
    verbose "${FUNCNAME} dns_fqdn=${dns_fqdn}" ${verbose_level}

    if [ ${#dns_data} -eq 0 ]; then
        dnsAlert "${FUNCNAME} dns_data is empty"
        return 1
    fi
    verbose "${FUNCNAME} dns_data=${dns_data}" ${verbose_level}

    if [[ ! ${dns_data_priority} =~ ^[0-9]+$ ]]; then
        dnsAlert "${FUNCNAME} dns_data_priority is not an integer"
        return 1
    fi
    verbose "${FUNCNAME} dns_data_priority=${dns_data_priority}" ${verbose_level}

    if [[ ! ${dns_data_ttl} =~ ^[0-9]+$ ]]; then
        dnsAlert "${FUNCNAME} dns_data_ttl is not an integer"
        return 1
    else
        if [ ${dns_data_ttl} -lt 10 ]; then
            dnsAlert "${FUNCNAME} dns_data_ttl can not be less than 10 seconds" ${verbose_level}
            return 1
        fi
    fi
    verbose "${FUNCNAME} dns_data_ttl=${dns_data_ttl}" ${verbose_level}

    if [ ${#dns_server} -eq 0 ]; then
        dnsAlert "${FUNCNAME} dns_server is empty"
        return 1
    fi

    if [ ${#dns_server_port} -eq 0 ] || [[ ! ${dns_server_port} =~ ^[0-9]+$ ]]; then
        dnsAlert "${FUNCNAME} dns_server_port is empty"
        return 1
    fi
    verbose "${FUNCNAME} dns_server=${dns_server} (${dns_server_port})" ${verbose_level}

    if [ ${#dns_zone} -eq 0 ]; then
        dnsAlert "${FUNCNAME} dns_zone is empty"
        return 1
    fi
    verbose "${FUNCNAME} dns_zone=${dns_zone}" ${verbose_level}

    if [ ${#dns_zone_arpa} -eq 0 ]; then
        aborting "${FUNCNAME} dns_zone_arpa is empty"
        return 1
    fi
    verbose "${FUNCNAME} dns_zone_arpa=${dns_zone_arpa}" ${verbose_level}

    verbose "${FUNCNAME} dns_zone_key=${dns_zone_key}" ${verbose_level}
    verbose "${FUNCNAME} dns_zone_keyfile=${dns_zone_keyfile}" ${verbose_level}

    local dns_class="IN"
    verbose "${FUNCNAME} dns_class=${dns_class}" ${verbose_level}

    # only change actions can proceed ...

    if [ "${dns_action}" != "add" ] && [ "${dns_action}" != "delete" ] && [ "${dns_action}" != "update" ]; then
        return 1
    fi

    local dns_add dns_delete

    if [ "${dns_action}" == "update" ]; then
        dns_add=0
        dns_delete=0
    else
        if [ "${dns_action}" == "add" ]; then
            dns_add=0
        else
            dns_add=1
        fi
        if [ "${dns_action}" == "delete" ]; then
            dns_delete=0
        else
            dns_delete=1
        fi
    fi

    local nsupdate_key_args
    if [ ${#dns_zone_keyfile} -gt 0 ] && [ -r "${dns_zone_keyfile}" ]; then
        nsupdate_key_args="-k ${dns_zone_keyfile}"
    fi
    verbose "${FUNCNAME} nsupdate_key_args=${nsupdate_key_args}" ${verbose_level}

    nsupdate_script="server ${dns_server} ${dns_server_port}\n"
    nsupdate_script+="zone ${dns_zone}.\n"
    if [ "${dns_zone_keyfile}" == "gsstsig" ]; then
        nsupdate_script+="gsstsig\n"
    fi
    if [ "${dns_zone_keyfile}" == "oldgsstsig" ]; then
        nsupdate_script+="oldgsstsig\n"
    fi

    if [ ${dns_delete} -eq 0 ]; then
        dnsEcho "[DELETE]: server ${dns_server}, ${dns_fqdn} ${dns_record} = ${dns_data}"
        if [ "${dns_record}" == "PTR" ]; then
            nsupdate_script+="update delete ${dns_zone_arpa}. ${dns_record}"
        else
            nsupdate_script+="update delete ${dns_fqdn}. ${dns_record}"
        fi
        nsupdate_script+="\n"
    fi

    if [ ${dns_delete} -eq 0 ] && [ ${dns_add} -eq 0 ]; then
        nsupdate_script+="\n"
    fi

    if [ ${dns_add} -eq 0 ]; then
        dnsEcho "[ADD]: server ${dns_server}, ${dns_fqdn} ${dns_record} = ${dns_data}"

        if [ "${dns_record}" == "PTR" ]; then
            #nsupdate_script+="prereq nxdomain ${dns_zone_arpa}.\n"
            nsupdate_script+="update add ${dns_zone_arpa}. ${dns_data_ttl} ${dns_record} ${dns_fqdn}."
        else
            nsupdate_script+="prereq nxdomain ${dns_fqdn}.\n"
            nsupdate_script+="update add ${dns_fqdn}. ${dns_data_ttl} ${dns_record} ${dns_data}"
            if [ "${dns_record}" == "CNAME" ]; then
                nsupdate_script+="."
            fi
        fi
        nsupdate_script+="\n"
    fi

    #nsupdate_script+="debug\n"
    nsupdate_script+="send\n"

    #printf "${nsupdate_script}"
    printf "${nsupdate_script}" | nsupdate ${Nsupdate_Args} ${nsupdate_key_args} &> /dev/null
    nsupdate_rc=$?

    if [ "${dns_zone_keyfile}" == "gsstsig" ] || [ "${dns_zone_keyfile}" == "oldgsstsig" ]; then
        # ugh, another windows workaround
        # https://bugzilla.redhat.com/show_bug.cgi?id=1394320

        local dns_lookup_rc=1

        if [ "${dns_record}" == "PTR" ]; then
            dnsLookup match "${dns_record}" "${dns_zone_arpa}" "${dns_fqdn}" "${dns_server}" "${dns_server_port}"
        else
            dnsLookup match "${dns_record}" "${dns_fqdn}" "${dns_data}" "${dns_server}" "${dns_server_port}"
        fi

        dns_lookup_rc=$?
        verbose "${FUNCNAME} dns_lookup_rc=${dns_lookup_rc}" ${verbose_level}
        if [ "${dns_action}" == "add" ] && [ ${dns_lookup_rc} -eq 0 ]; then
            nsupdate_rc=0
        fi
        if [ "${dns_action}" == "delete" ] && [ ${dns_lookup_rc} -ne 0 ]; then
            nsupdate_rc=0
        fi
    fi

    verbose "${FUNCNAME} nsupdate ${Nsupdate_Args} ${nsupdate_key_args} &> /dev/null [${nsupdate_rc}]" ${verbose_level}

    return ${nsupdate_rc}
}


# validate ip address and standard output arpa zone (if appropriate)
function dnsZoneArpa() {
    local -u dns_record="${1}"
    local dns_data="${2}"

    local verbose_level=18

    if [ ${#dns_record} -eq 0 ] || [ ${#dns_data} -eq 0 ]; then
        return 0
    fi

    verbose "${FUNCNAME} dns_record=${dns_record}" ${verbose_level}
    verbose "${FUNCNAME} dns_data=${dns_data}" ${verbose_level}

    local dns_record_ip_family

    dns_record_ip_family=1

    local dns_record_ips=(A AAAA PTR)
    for dns_record_ip in ${dns_record_ips[@]}; do
        if [ "${dns_record}" == "${dns_record_ip}" ]; then
            if (ipcalc -c -4 "${dns_data}" &> /dev/null); then

                if [ "${dns_record_ip}" == "A" ] || [ "${dns_record_ip}" == "PTR" ]; then
                    # in-addr.arpa
                    dns_record_ip_family=4
                    # host nicely converts an ip address to in-addr reverse format
                    host ${Host_Args} "${dns_data}" 2> /dev/null | sed -e 's#^Host[[:space:]]##g' | awk '{print $1}' | sed -e '/\.*$/s///g'
                    break
                fi
            else
                if (ipcalc -c -6 "${dns_data}" &> /dev/null); then

                    if [ "${dns_record_ip}" == "AAAA" ] || [ "${dns_record_ip}" == "PTR" ]; then
                        # ip6.arpa
                        dns_record_ip_family=6
                        # host nicely converts an ip address to ip6 reverse format
                        host ${Host_Args} "${dns_data}" 2> /dev/null | sed -e 's#^Host[[:space:]]##g' | awk '{print $1}' | sed -e '/\.*$/s///g'
                        break
                    fi
                else
                    dnsAlert "${dns_data} is an invalid IP address"
                    return 1
                fi
            fi
        fi
    done

    verbose "${FUNCNAME} dns_record_ip_family=${dns_record_ip_family}" ${verbose_level}

    return ${dns_record_ip_family}
}


# output matching DNS_Zone config key value from dns.conf
function dnsZoneConfig() {
    local dns_zone_config_value="$1"
    local dns_config_file="$2"
    local dns_config_view="$3"

    local verbose_level=18

    if [ ${#dns_zone_config_value} -eq 0 ]; then
        return 1
    fi

    if [ ${#dns_config_file} -eq 0 ]; then
        dns_config_file="${Dns_Config_File}"
    fi

    if [ ${#dns_config_file} -eq 0 ]; then
        # is it OK *not* to have a config file?  should be ...
        dnsAlert "${FUNCNAME} dns configuration file missing; value is empty"
        return 1
    else
        if [ ! -r "${dns_config_file}" ]; then
            dnsAlert "${FUNCNAME} dns configuration file missing; '${dns_config_file}' file not readable"
            return 1
        fi
    fi

    verbose "${FUNCNAME} dns_config_file=${dns_config_file}" ${verbose_level}

    if [ ${#dns_config_view} -gt 0 ]; then
        dns_config_view+=","
    fi

    set -o pipefail

    local config_data config_data_rc
    local dns_zone_config_value_dots="${dns_zone_config_value//[^\.]}"
    local dns_zone_config_value_dots=${#dns_zone_config_value_dots}

    while [ ${dns_zone_config_value_dots} -gt 0 ]; do
        verbose "${FUNCNAME} dns_zone_config_value_dots=${dns_zone_config_value_dots} (${dns_zone_config_value})" ${verbose_level}

        # strip spaces!
        config_data=$(sed -e '/[[:space:]]/s///g' "${dns_config_file}" 2> /dev/null | egrep -e "^Dns_Zone=${dns_zone_config_value},${dns_config_view}" | head -1 | awk -F# '{print $1}')
        config_data=${config_data#*=}

        # set rc
        config_data_rc=$?

        if [ ${#config_data} -gt 0 ]; then
            verbose "${FUNCNAME} config_data=${config_data}" ${verbose_level}
            break;
        fi

        dns_zone_config_value=${dns_zone_config_value#*.}
        let dns_zone_config_value_dots=${dns_zone_config_value_dots}-1
    done

    echo ${config_data}

    # return pipefail result code
    return ${config_data_rc}

}


# output valid dns zone keyfile
function dnsZoneKeyfile() {
    local -l dns_zone="${1}"
    local dns_server="${2}"
    local dns_server_port="${3}"
    local dns_zone_key="${4}"
    local dns_view="${5}"

    local verbose_level=18

    # only allow public & private views
    if [ "${dns_view}" != "private" ] && [ "${dns_view}" != "public" ]; then
        dns_view=""
    fi

    verbose "${FUNCNAME} dns_zone=${dns_zone}" ${verbose_level}
    verbose "${FUNCNAME} dns_server=${dns_server} (${dns_server_port})" ${verbose_level}
    verbose "${FUNCNAME} dns_zone_key=${dns_zone_key}" ${verbose_level}
    verbose "${FUNCNAME} dns_view=${dns_view}" ${verbose_level}

    local dns_zone_keyfile

    if [ ${#dns_zone} -eq 0 ]; then
        return 1
    fi

    local -u dns_user
    local dns_pass

    if [ ${#dns_zone_key} -gt 0 ]; then
        if [ -r "${dns_zone_key}" ]; then
            dns_zone_keyfile="${dns_zone_key}"
            dns_zone_key=$(grep ^key.*\{ "${dns_zone_key}" 2> /dev/null | awk '{print $2}' | sed -e '/"/s///g' -e "/'/s///g")
            if [ ${#dns_zone_key} -eq 0 ]; then
                dnsAlert "'${dns_zone_keyfile}' invalid key file"
                return 1
                # invalid key, reset
                dns_zone_key="${dns_zone_keyfile}"
                dns_zone_keyfile=""
            fi
        else
            if [ -f "${dns_zone_key}" ]; then
                dnsAlert "'${dns_zone_key}' file not readable"
                return 1
            else
                if [[ "${dns_zone_key}" == *"@"* ]] && [[ "${dns_zone_key}" == *":"* ]]; then
                    dns_user=${dns_zone_key%:*}
                    dns_pass=${dns_zone_key##*:}
                    dns_zone_keyfile="gsstsig"
                fi
            fi
        fi
    fi

    local dns_dependencies dns_dependency dns_dependency_exec dns_dependency_fail

    dns_dependency_fail=1
    if [ "${dns_zone_keyfile}" == "gsstsig" ] && [ ${#dns_user} -gt 0 ] && [ ${#dns_pass} -gt 0 ]; then
        verbose "${FUNCNAME} dns_user=${dns_user}, dns_pass=${dns_pass}" ${verbose_level}

        dns_dependencies=()
        dns_dependencies+=(kinit)
        #dns_dependencies+=(klist)
        for dns_dependency in ${dns_dependencies[@]}; do
            verbose "${FUNCNAME} dns_dependency=${dns_dependency}" $((${verbose_level}+10))
            [ ${#dns_dependency} -eq 0 ] && continue
            dns_dependency_exec=$(type -P "${dns_dependency}")
            if [ ! -f "${dns_dependency_exec}" ] && [ ! -x "${dns_dependency_exec}" ]; then
                dnsAlert "${FUNCNAME} dns dependency '${dns_dependency_exec}' file not found executable"
                dns_dependency_fail=0
                break
            fi
        done
        unset dns_dependency dns_dependency_exec

        if [ ${dns_dependency_fail} -eq 0 ]; then
            return 1
        fi

        local kinit_rc

        kinit_rc=1

        set -o pipefail

        # todo: needs more testing ...
        #if klist -s; then
        #if (klist -A 2> /dev/null | grep -q "^Default principal: ${dns_user}$"); then
        #kinit_rc=0
        #else
        echo "${dns_pass}" | kinit "${dns_user}" &> /dev/null
        kinit_rc=$?
        #fi

        verbose "${FUNCNAME} kinit_rc=${kinit_rc}" ${verbose_level}

        if [ ${kinit_rc} -ne 0 ]; then
            dnsAlert "kinit failed for '${dns_user}'"
            return 1
        fi
    fi

    local dns_zone_keyfiles nsupdate_key_args

    if [ ${#dns_zone_keyfile} -eq 0 ]; then
        dns_zone_keyfiles=()
        if [ ${#dns_zone_key} -eq 0 ] && [ ${#dns_zone_keyfile} -eq 0 ] && [ ${#dns_view} -eq 0 ]; then
            dns_zone_keyfiles=(none)
        fi
        dns_zone_keyfiles+=($(find ${Dns_Dir}/etc -type f -name "named*zone.key" 2> /dev/null | sort -u))
        dns_zone_keyfiles+=($(find /etc -type f -name "named*zone.key" 2> /dev/null | sort -u))
        if [ -r /etc/rndc.key ]; then
            dns_zone_keyfiles+=(/etc/rndc.key)
        fi
        if [ -r /etc/rndc.conf ]; then
            dns_zone_keyfiles+=(/etc/rndc.conf)
        fi
    else
        dns_zone_keyfiles=("${dns_zone_keyfile}")
    fi

    if [ ${#dns_zone_key} -gt 0 ] || [ ${#dns_zone_keyfile} -gt 0 ] || [ ${#dns_view} -gt 0 ]; then
        for dns_zone_keyfile in "${dns_zone_keyfiles[@]}"; do
            [ "${dns_zone_keyfile}" == "" ] && continue
            [ "${dns_zone_keyfile}" == "none" ] && continue
            [ ! -r "${dns_zone_keyfile}" ] && continue

            if [ ${#dns_zone_key} -gt 0 ]; then
                grep "^key.*[$|\"]${dns_zone_key}[$|\"].*{" "${dns_zone_keyfile}" &> /dev/null
                if [ $? -eq 0 ]; then
                    # found matching keyfile
                    break
                fi
            fi

            if [ ${#dns_view} -gt 0 ]; then
                if [[ "${dns_zone_keyfile}" == *".${dns_view}.zone.key"* ]]; then
                    # found matching keyfile
                    if [ ${#dns_zone_key} -eq 0 ]; then
                        dns_zone_key=$(grep ^key.*\{ "${dns_zone_keyfile}" 2> /dev/null | awk '{print $2}' | sed -e '/"/s///g' -e "/'/s///g")
                    fi
                    break
                fi
            fi
        done
    fi

    local dns_zone_key_valid=1 # false

    if [ ${#dns_zone_keyfile} -gt 0 ]; then
        if [ "${dns_zone_keyfile}" != "none" ]; then
            if [ "${dns_zone_keyfile}" == "gsstsig" ]; then
                dns_zone_keyfiles=("gsstsig" "oldgsstsig")
            else
                dns_zone_keyfiles=("${dns_zone_keyfile}" none)
            fi
        fi
    fi

    local local nsupdate_key_args nsupdate_rc nsupdate_script
    for dns_zone_keyfile in "${dns_zone_keyfiles[@]}"; do
        [ "${dns_zone_keyfile}" == "" ] && continue
        verbose "(1) dns_zone_keyfile=${dns_zone_keyfile}" ${verbose_level}

        unset nsupdate_key_args

        if [ "${dns_zone_keyfile}" != "none" ] && [ -r "${dns_zone_keyfile}" ]; then
            nsupdate_key_args="-k ${dns_zone_keyfile}"
        else
            nsupdate_key_args=""
        fi

        nsupdate_script="server ${dns_server} ${dns_server_port}\n"
        nsupdate_script+="zone ${dns_zone}.\n"
        if [ "${dns_zone_keyfile}" == "gsstsig" ]; then
            nsupdate_script+="gsstsig\n"
        fi
        if [ "${dns_zone_keyfile}" == "oldgsstsig" ]; then
            nsupdate_script+="oldgsstsig\n"
        fi
        #nsupdate_script+="debug\n"
        nsupdate_script+="send\n"
        nsupdate_script+="answer\n"

        #(>&2 printf "${nsupdate_script}")
        if [ "${dns_zone_keyfile}" == "gsstsig" ] || [ "${dns_zone_keyfile}" == "oldgsstsig" ]; then
            # https://bugzilla.redhat.com/show_bug.cgi?id=1394320
            set +o pipefail
            printf "${nsupdate_script}" | nsupdate ${Nsupdate_Args} ${nsupdate_key_args} 2> /dev/null | grep -q ".*ANY.*TSIG.*NOERROR[[:space:]]0"
        else
            printf "${nsupdate_script}" | nsupdate ${Nsupdate_Args} ${nsupdate_key_args} &> /dev/null
        fi
        nsupdate_rc=$?

        verbose "nsupdate ${Nsupdate_Args} ${nsupdate_key_args} &> /dev/null [${nsupdate_rc}]" ${verbose_level}

        if [ ${nsupdate_rc} -eq 0 ]; then
            # success
            if [ ${#dns_zone_key} -eq 0 ] && [ "${dns_zone_keyfile}" != "none" ] && [ -r "${dns_zone_keyfile}" ]; then
                dns_zone_key=$(grep ^key.*\{ "${dns_zone_keyfile}" 2> /dev/null | awk '{print $2}' | sed -e '/"/s///g' -e "/'/s///g")
            fi
            if [ "${dns_zone_keyfile}" == "none" ]; then
                dns_zone_key=""
                dns_zone_keyfile=""
            fi
            dns_zone_key_valid=0 # true
            break
        fi

        if [ -f "${dns_zone_keyfile}" ]; then
            dnsAlert "dns server '${dns_server}' rejected dns zone key file '${dns_zone_keyfile}'"
        else
            dnsAlert "dns server '${dns_server}' rejected dns zone key '${dns_zone_keyfile}'"
        fi
    done

    verbose "dns_zone_key=${dns_zone_key} [${dns_zone_key_valid}], dns_zone_keyfile=${dns_zone_keyfile}, dns_zone_keyfiles=${dns_zone_keyfiles[@]}" ${verbose_level}

    if [ ${#dns_zone_keyfile} -gt 0 ] && [ ${dns_zone_key_valid} -eq 0 ]; then
        printf "${dns_zone_keyfile}"
        if [ ${#dns_zone_key} -gt 0 ]; then
            printf ",${dns_zone_key}"
        fi
        printf "\n"
    else
        if [ ${#dns_zone_keyfile} -gt 0 ] && [ ! -r ${dns_zone_keyfile} ]; then
            dns_zone_key_valid=1 # false
        fi
        dns_zone_key=""
        dns_zone_keyfile=""
    fi

    verbose "dns_zone_key=${dns_zone_key}" ${verbose_level}
    verbose "(2) dns_zone_keyfile=${dns_zone_keyfile}" ${verbose_level}

    return ${dns_zone_key_valid}
}


# output dns zone master based on a valid SOA
function dnsZoneMname() {
    local dns_data="${1}"
    local dns_server="${2}"
    local dns_server_port="${3}"

    local verbose_level=18

    local dns_lookup_rc=1

    local dns_data_dots="${dns_data//[^\.]}"
    local dns_data_dots=${#dns_data_dots}

    local dns_mname
    while [ ${dns_data_dots} -gt 0 ]; do
        verbose "dns_data_dots=${dns_data_dots} (${dns_data})" ${verbose_level}
        dns_mname=$(host -t soa ${Host_Args} ${dns_data} ${dns_server} 2> /dev/null | head -1 | grep has\ SOA\ record | awk '{print $5}')
        if [ ${#dns_mname} -ne 0 ]; then
            dns_lookup_rc=0
            break
        fi
        dns_data=${dns_data#*.}
        let dns_data_dots=${dns_data_dots}-1
    done

    verbose "dns_data=${dns_data}, dns_lookup_rc=${dns_lookup_rc}" ${verbose_level}

    if [ ${#dns_mname} -gt 0 ]; then
        echo "${dns_mname}"
        return 0
    fi

    return 1

}


# output dns zone based on a valid SOA
function dnsZoneSOA() {
    local dns_fqdn="${1}"
    local dns_data="${2}"
    local dns_server="${3}"
    local dns_server_port="${4}"

    local verbose_level=18

    local dns_lookup_rc=1

    local dns_fqdn_dots="${dns_fqdn//[^\.]}"
    local dns_fqdn_dots=${#dns_fqdn_dots}

    set -o pipefail

    while [ ${dns_fqdn_dots} -gt 0 ]; do
        verbose "${FUNCNAME} dns_fqdn_dots=${dns_fqdn_dots} (${dns_fqdn})" ${verbose_level}
        if dnsLookup exists "SOA" "${dns_fqdn}" "${dns_fqdn}" "${dns_server}" "${dns_server_port}"; then
            dns_lookup_rc=0
            break
        fi
        dns_fqdn=${dns_fqdn#*.}
        let dns_fqdn_dots=${dns_fqdn_dots}-1
    done

    verbose "${FUNCNAME} dns_fqdn=${dns_fqdn}, dns_lookup_rc=${dns_lookup_rc}" ${verbose_level}

    if [ ${dns_lookup_rc} -eq 0 ] && [ ${#dns_fqdn} -gt 0 ]; then
        echo "${dns_fqdn}"
        return 0
    fi

    return 1

}


# output a 'usage' message and exit with a non-zero return code
function usage() {
    printf "\nusage:\n\n%s <action> <record> <name> <data> [-t <ttl>] [-p <priority>] [-s <server>] [-k <key>] [--force] [--help]\n\n" "${0}"

    if [ "${Dns_Actions}" != "" ]; then
        printf "supported actions:\n\n"
        let Dns_Action_Count=0
        for Dns_Action in ${Dns_Actions[@]}; do
            if [ ${Dns_Action_Count} -eq 0 ]; then
                printf "    ${Dns_Action}"
            else
                printf ", ${Dns_Action}"
            fi
            let Dns_Action_Count=${Dns_Action_Count}+1
        done
        printf "\n\n"
        unset Dns_Action
    fi

    if [ "${Dns_Records}" != "" ]; then
        printf "supported records:\n\n"
        let Dns_Record_Count=0
        for Dns_Record in ${Dns_Records[@]}; do
            if [ ${Dns_Record_Count} -eq 0 ]; then
                printf "    ${Dns_Record}"
            else
                printf ", ${Dns_Record}"
            fi
            let Dns_Record_Count=${Dns_Record_Count}+1
        done
        printf "\n\n"
        unset Dns_Record
    fi

    printf "supported options:\n\n"
    printf "    -a|--all                = automatically action all records, e.g. A and PTR\n"
    printf "    -f|--force              = force action to complete; by default, add will only be allowed if a record doesn't exist, etc.\n"
    printf "    -h|--help               = show usage help and exit\n";
    printf "    -k|--key <file|name>    = specify key name or key file\n"
    printf "    -p|--priority <integer> = specify dns data priority, e.g. for MX records, default ${Default_Data_Priority}\n"
    printf "    -s|--server <ip>        = specify dns server to action, default automatically resolve\n"
    printf "    -t|--ttl <integer>      = specify dns data time to live, default ${Default_Data_TTL} seconds\n"
    printf "    -v|--view <name>        = specify dns view name"
    printf "\n"

    # todo: add examples

    if [ ${#1} -ne 0 ]; then
        local usage_message="${@}"
        printf "NOTE: %s\n\n" "${usage_message}"
    fi
    exit 1
}

if [ "$(type -t verbose)" != "function" ]; then
    function verbose() {
        local verbose_arguments=($@)
        local verbose_level verbose_message

        if [ ${#2} -gt 0 ]; then
            verbose_message=(${verbose_arguments[@]}) # preserve verbose_arguments
            verbose_level=${verbose_message[${#verbose_message[@]}-1]}
        else
            verbose_message="${1}"
            verbose_level=""
        fi

        if [[ ! ${verbose_level} =~ ^[0-9]+$ ]]; then
            verbose_level=0
        fi

        if [[ ${Verbose} =~ ^[0-9]+$ ]]; then
            if [ ${verbose_level} -le ${Verbose} ]; then
                (>&2 printf "%b\n" "${verbose_message}")
            fi
        fi
    }
fi

#
# Main
#

verbose "Verbose = ${Verbose}" ${Verbose_Level}

Failure_Reason=""

Dns_Basename=$(basename $0)
verbose "Dns_Basename=${Dns_Basename}" ${Verbose_Level}

#
# validate dns directory
#

# dns.conf must exist?

if [ -r "/etc/dns.conf" ]; then
    Dns_Config_File="/etc/dns.conf"
fi

if [ "${BASH_SOURCE}" != "${0}" ]; then
    Dns_Dir=$(dirname "$(readlink -e "${BASH_SOURCE}")")
else
    Dns_Dir=$(dirname "$(readlink -e "${0}")")
fi

if [ -d "${Dns_Dir}/../zone" ] && [ -r "${Dns_Dir}/../zone" ]; then
    Dns_Dir=$(dirname "${Dns_Dir}")
fi

if [ ${#Dns_Dir} -eq 0 ]; then
    aborting "dns directory value is empty"
fi

if [ ! -d "${Dns_Dir}" ] || [ ! -r "${Dns_Dir}" ]; then
    aborting "dns directory; '${Dns_Dir}' directory not readable"
fi

if [ -f "${Dns_Dir}/etc/named.primary.conf" ] && [ -f "${Dns_Dir}/etc/named.secondary.conf" ]; then
    if [ ${#Dns_Config_File} -eq 0 ] && [ -r "${Dns_Dir}/etc/dns.conf" ]; then
        Dns_Config_File="${Dns_Dir}/etc/dns.conf"
    fi
    if [ -r /etc/named.conf ]; then
        # primary & secondary servers using this script additionally require these ...
        if [ -r /etc/rndc.key ] || [ -r /etc/rndc.conf ]; then
            Dns_Dependencies+=(rndc)
            Rndc_Flag=0
        fi
    fi
fi

verbose "Dns_Dir=${Dns_Dir}" ${Verbose_Level}

PATH=${Dns_Dir}/bin:${Dns_Dir}/sbin:${PATH}

#
# validate dependencies
#

for Dns_Dependency in ${Dns_Dependencies[@]}; do
    verbose "Dns_Dependency=${Dns_Dependency}" $((${Verbose_Level}+10))
    [ ${#Dns_Dependency} -eq 0 ] && continue
    Dns_Dependency_Exec=$(type -P "${Dns_Dependency}")
    if [ ! -f "${Dns_Dependency_Exec}" ] && [ ! -x "${Dns_Dependency_Exec}" ]; then
        aborting "dependency missing; '${Dns_Dependency}' file not executable"
    fi
done
unset Dns_Dependency Dns_Dependency_Exec

#
# validate BASH_SOURCE
#

# for reusable functions; return if this script was sourced
if [ "${BASH_SOURCE}" != "${0}" ]; then
    if [ ${#Dns_Config_File} -eq 0 ]; then
        aborting "dns.conf file not found"
    fi
    return
else
    # first four arguments are required
    if [ ${#1} -eq 0 ] || [ ${#2} -eq 0 ] || [ ${#3} -eq 0 ] || [ ${#4} -eq 0 ]; then
        usage
    fi
fi

#
# Main (cli)
#

Dns_Date=0

#
# capture arguments
#

Arguments=$@

#
# validate dns action
#

Dns_Action_Valid=1
for Dns_Action in ${Dns_Actions[@]}; do
    if [ "${1,,}" == "${Dns_Action}" ]; then
        Dns_Action_Valid=0
        break
    fi
done
if [ ${Dns_Action_Valid} -eq 1 ]; then
    usage "invalid action '${1}'"
else
    shift
fi
verbose "Dns_Action=${Dns_Action}" ${Verbose_Level}

#
# validate dns record (type)
#

Dns_Record_Valid=1
for Dns_Record in ${Dns_Records[@]}; do
    if [ "${1^^}" == "${Dns_Record}" ]; then
        Dns_Record_Valid=0
        break
    fi
done
if [ ${Dns_Record_Valid} -eq 1 ]; then
    usage "invalid record '${1}'"
else
    shift
fi
verbose "Dns_Record=${Dns_Record}" ${Verbose_Level}

#
# validate name; set default zone & fqdn
#

Dns_Name=$(echo "$1" | sed -e 's#\.\.*#\.#g' -e 's#^\.##g' -e 's#\.$##g' -e '/\.*$/s///g')

if [ ${#Dns_Name} -eq 0 ]; then
    aborting "invalid dns name '$1'"
else
    shift
fi

Dns_Name_Dots="${Dns_Name//[^\.]}"
Dns_Name_Dots=${#Dns_Name_Dots}

if [ ${Dns_Name_Dots} -eq 0 ]; then
    # should default be the first in the resolv.conf search list?
    # first, try to set default zone from dns.conf
    Dns_Zone_Default=$(dnsConfig Dns_Zone_Default | sed -e 's#\.\.*#\.#g' -e 's#^\.##g' -e 's#\.$##g');
    if [ ${#Dns_Zone_Default} -eq 0 ]; then
        # second, try to use /etc/resolv.conf
        if [ -r /etc/resolv.conf ]; then
            Dns_Zone_Default=$(grep ^search\  /etc/resolv.conf 2> /dev/null | head -1 | awk '{print $2}')
        fi
        if [ ${#Dns_Zone_Default} -eq 0 ]; then
            verbose "Dns_Zone_Default is NOT set, using localdomain" ${Verbose_Level}
            Dns_Zone_Default=localdomain
        fi
    fi

    if [ ${#Dns_Zone_Default} -gt 0 ]; then
        Dns_FQDN=${Dns_Name}.${Dns_Zone_Default}
    else
        Dns_FQDN="${Dns_Name}"
    fi
else
    Dns_FQDN="${Dns_Name}"
fi

Dns_FQDN=$(echo "${Dns_FQDN}" | sed -e '/\.*$/s///g')

if [ "${Dns_Name}" != "${Dns_FQDN}" ]; then
    verbose "Dns_Name=${Dns_Name} (${Dns_Name_Dots} dots)" ${Verbose_Level}
fi

if [ ${#Dns_FQDN} -eq 0 ]; then
    aborting "unable to determine fully qualified domain name"
else
    verbose "Dns_FQDN=${Dns_FQDN}" ${Verbose_Level}
fi

#
# validate dns data
#

Dns_Data="$1"
shift

verbose "Dns_Data=${Dns_Data}" ${Verbose_Level}

#
# validate dns zone arpa
#

Dns_Zone_Arpa=$(dnsZoneArpa "${Dns_Record}" "${Dns_Data}")
Dns_Record_IP_Family=$?

verbose "Dns_Zone_Arpa=${Dns_Zone_Arpa}" ${Verbose_Level}

#
# validate dns record ip family
#

if [ ${Dns_Record_IP_Family} -ne 4 ] && [ ${Dns_Record_IP_Family} -ne 6 ]; then
    aborting "${Dns_Data} is an invalid IP address for an ${Dns_Record} record"
fi

verbose "Dns_Record_IP_Family=${Dns_Record_IP_Family}" ${Verbose_Level}

#
# parse cli options
#

# translate long options to short
for arg; do
    quote=""
    case "${arg}" in
        -all|--all)
            args="${args}-f "
            ;;
        -force|--force)
            args="${args}-f "
            ;;
        -help|--help)
            args="${args}-h "
            ;;
        -key|--key)
            args="${args}-k "
            ;;
        -port|--port)
            args="${args}-P "
            ;;
        -priority|--priority)
            args="${args}-p "
            ;;
        -server|--server)
            args="${args}-s "
            ;;
        -ttl|--ttl)
            args="${args}-t "
            ;;
        -view|--view)
            args="${args}-v "
            ;;
        *)
            [[ "${arg:0:1}" == "-" ]] || quote="\""
            args="${args}${quote}${arg}${quote} "
            ;;
    esac
done
eval set -- ${args}

# process short options
while getopts ":afhk:P:p:s:t:v:" option; do
    case "${option}" in
        a)
            All_Flag=0 # true
            ;;
        f)
            Force_Flag=0 # true
            ;;
        h)
            usage
            ;;
        k)
            Dns_Zone_Key=${OPTARG}
            ;;
        P)
            Dns_Server_Port=${OPTARG}
            ;;
        p)
            Dns_Data_Priority=${OPTARG}
            ;;
        s)
            Dns_Server=${OPTARG}
            ;;
        t)
            Dns_Data_TTL=${OPTARG}
            ;;
        v)
            Dns_View=${OPTARG}
            ;;
        :)
            aborting "option '-${OPTARG}' requires an argument"
            ;;
        *)
            aborting "unknown option '${@}'"
            ;;
    esac
done

#
# validate force
#

verbose "All_Flag = ${All_Flag}" ${Verbose_Level}
verbose "Force_Flag = ${Force_Flag}" ${Verbose_Level}

#
# validate data priority
#

if [[ ! ${Dns_Data_Priority} =~ ^[0-9]+$ ]]; then
    Dns_Data_Priority=${Default_Data_Priority}
fi

verbose "Dns_Data_Priority=${Dns_Data_Priority}" ${Verbose_Level}

#
# validate data ttl
#

if [[ ! ${Dns_Data_TTL} =~ ^[0-9]+$ ]]; then
    Dns_Data_TTL=${Default_Data_TTL}
fi

verbose "Dns_Data_TTL=${Dns_Data_TTL}" ${Verbose_Level}

#
# validate zone view
#

# dns view is optional; the default view will be whatever the remote named assigns to the dns server ip
if [ ${#Dns_View} -gt 0 ]; then
    verbose "Dns_View=${Dns_View}" ${Verbose_Level}
fi

#
# final validation
#

if [ ! -d "${Dns_Dir}" ] || [ ! -r "${Dns_Dir}" ]; then
    aborting "'${Dns_Dir}' directory not readable"
fi

if [ ${#Dns_Action} -eq 0 ]; then
    aborting "Dns_Action is empty"
fi

if [ ${#Dns_Record} -eq 0 ]; then
    aborting "Dns_Record is empty"
fi

if [ ${#Dns_FQDN} -eq 0 ]; then
    aborting "Dns_FQDN is empty"
fi

if [ ${#Dns_Data} -eq 0 ]; then
    aborting "Dns_Data is empty"
fi

if [[ ! ${Dns_Data_Priority} =~ ^[0-9]+$ ]]; then
    aborting "Dns_Data_Priority is not an integer"
fi

if [[ ! ${Dns_Data_TTL} =~ ^[0-9]+$ ]]; then
    aborting "Dns_Data_TTL is not an integer"
fi

#
# validate what resource records should be actioned
#

Dns_RRS=()
if [ ${All_Flag} -eq 1 ]; then
    Dns_RRS=(${Dns_Record})
else
    if [ "${Dns_Record}" == "A" ] || [ "${Dns_Record}" == "AAAA" ]; then
        Dns_RRS=(${Dns_Record} PTR)
    else
        if [ "${Dns_Record}" == "PTR" ]; then
            if [ ${Dns_Record_IP_Family} -eq 4 ]; then
                Dns_RRS=(${Dns_Record} A)
            else
                if [ ${Dns_Record_IP_Family} -eq 6 ]; then
                    Dns_RRS=(${Dns_Record} AAAA)
                else
                    aborting "${Dns_Data} is not a valid IP address"
                fi
            fi
        else
            Dns_RRS=(${Dns_Record})
        fi
    fi
fi

verbose "Dns_RRS=${Dns_RRS[@]}" ${Verbose_Level}

#
# validate dns admin email
#

if ! Dns_Admin_Email=$(dnsConfig Dns_Admin_Email); then
    Dns_Admin_Email=root
fi

verbose "Dns_Admin_Email=${Dns_Admin_Email}" ${Verbose_Level}

####################################################################################################################################
####################################################################################################################################
####################################################################################################################################
####################################################################################################################################
####################################################################################################################################

# !!!!!! everything up to this point is mutually exclusive with regard to either forward or reverse lookups

Dns_RC=0

for Dns_RR in ${Dns_RRS[@]}; do
    Dns_RR=${Dns_RR^^}

    verbose "Dns_RR=${Dns_RR}" ${Verbose_Level}

    unset -v Dns_Action_RR Dns_Action_RRS
    unset -v Dns_Data_RR Dns_FQDN_RR
    unset -v Dns_Server_RR Dns_Server_IP_RR Dns_Server_Port_RR
    unset -v Dns_Status Dns_Status_RR
    unset -v Dns_View_RR
    unset -v Dns_Zone_RR Dns_Zone_Config_RR Dns_Zone_SOA_RR Dns_Zone_Key_RR Dns_Zone_Keyfile_RR

    #
    # validate forward/reverse dns FQDN
    #

    # it's possible that the forward and reverse authoritative nameservers are different!
    if [ ${#Dns_Zone_Arpa} -gt 0 ] && [ "${Dns_RR}" == "PTR" ]; then
        Dns_Data_RR="${Dns_FQDN}"
        Dns_FQDN_RR="${Dns_Zone_Arpa}"
    else
        Dns_Data_RR="${Dns_Data}"
        Dns_FQDN_RR="${Dns_FQDN}"
    fi

    if [ ${#Dns_FQDN_RR} -eq 0 ]; then
        dnsAlert "can't determine authoritative dns server for '${Dns_FQDN}' ${Dns_RR}' '${Dns_Data_RR}' record"
        Dns_RC=1
        continue
    fi

    verbose "Dns_Data_RR=${Dns_Data_RR}" ${Verbose_Level}
    verbose "Dns_FQDN_RR=${Dns_FQDN_RR}" ${Verbose_Level}

    #
    # validate (authoritative) dns server(s)
    #

    if [ ${#Dns_Server} -gt 0 ]; then
        # honor cli option
        Dns_Server_RR=${Dns_Server}
    else
        # no dns server given on cli; (attempt to) obtain from dns config

        Dns_Zone_Config_RR=$(dnsZoneConfig "${Dns_FQDN_RR}" "${Dns_Config_File}" "${Dns_View}")

        if [ ${#Dns_Zone_Config_RR} -gt 0 ]; then
            verbose "Dns_Zone_Config_RR=${Dns_Zone_Config_RR}" ${Verbose_Level}

            Dns_Zone_RR=$(echo "${Dns_Zone_Config_RR}" | awk -F, '{print $1}')

            # honor cli option
            if [ ${#Dns_View} -eq 0 ]; then
                Dns_View_RR=$(echo "${Dns_Zone_Config_RR}" | awk -F, '{print $2}')
            else
                Dns_View_RR="${Dns_View}"
            fi

            # honor cli option
            if [ ${#Dns_Server} -eq 0 ]; then
                Dns_Server_RR=$(echo "${Dns_Zone_Config_RR}" | awk -F, '{print $3}')

                if [[ "${Dns_Server_RR}" == *";"* ]]; then
                    Dns_Server_RR=${Dns_Server_RR%%;*}
                fi
            else
                Dns_Server_RR="${Dns_Server}"
            fi

            # honor cli option
            if [ ${#Dns_Zone_Key} -eq 0 ]; then
                Dns_Zone_Key_RR=$(echo "${Dns_Zone_Config_RR}" | awk -F, '{print $4}')
            else
                Dns_Zone_Key_RR="${Dns_Zone_Key}"
            fi

        else
            Warning="Dns_Zone for '${Dns_FQDN_RR}'"
            if [ ${#Dns_View} -gt 0 ]; then
                Warning+=", view '${Dns_View}'"
            fi
            Warning+=" not configured in '${Dns_Config_File}'"
            dnsAlert "${Warning}"
        fi
    fi

    if [ ${#Dns_Server_RR} -eq 0 ]; then
        # note: this ultimately uses the local resolve.conf & may be incorrect; useful, but as a last resort!
        Dns_Server_RR=$(dnsZoneMname "${Dns_FQDN_RR}")
    fi

    Dns_Server_RR=$(echo "${Dns_Server_RR}" | sed -e '/\.*$/s///g')

    if [ ${#Dns_Server_RR} -eq 0 ]; then
        dnsAlert "can't determine authoritative dns server for '${Dns_FQDN_RR}' ${Dns_RR}' record"
        Dns_RC=1
        continue
    fi

    #
    # validate dns server ip
    #

    # debt; use dnsLookup (it supports ports), don't use host
    Dns_Server_IP_RR=$(host ${Host_Args} -${Dns_Record_IP_Family} ${Dns_Server_RR} ${Dns_Server_RR} 2> /dev/null | grep '^.*has address ' | awk '{print $NF}' | sort -t. -k1rn -k2n -k3n -k4n | head -1)

    if [ ${#Dns_Server_IP_RR} -eq 0 ]; then
        # note: this ultimately uses the local resolve.conf & may be incorrect; useful, but as a last resort!
        Dns_Server_IP_RR=$(getent ahosts ${Dns_Server_RR} 2> /dev/null | grep STREAM | sort -t. -k1rn -k2n -k3n -k4n | head -1 | awk '{print $1}')
    fi

    if [ ${#Dns_Server_IP_RR} -eq 0 ]; then
        dnsAlert "can't determine authoritative dns server address for '${Dns_FQDN_RR}' ${Dns_RR}' record (no a/cname record for mname?)"
        Dns_RC=1
        continue
    fi

    #
    # validate dns server port
    #

    if [ ${#Dns_Server_Port} -gt 0 ] && [[ ${Dns_Server_Port} =~ ^[0-9]+$ ]]; then
        # honor cli option
        Dns_Server_Port_RR=${Dns_Server_Port}
    else
        Dns_Server_Port_RR=53
    fi

    if [ ${#Dns_Server_Port_RR} -eq 0 ]; then
        dnsAlert "can't determine dns server port for '${Dns_FQDN_RR}' ${Dns_RR}' record"
        Dns_RC=1
        continue
    fi

    verbose "Dns_Server_RR=${Dns_Server_RR} (${Dns_Server_IP_RR} port ${Dns_Server_Port_RR})" ${Verbose_Level}

    #
    # validate dns zone
    #

    Dns_Zone_SOA_RR=$(dnsZoneSOA "${Dns_FQDN_RR}" "${Dns_Data_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}")
    verbose "Dns_Zone_SOA_RR=${Dns_Zone_SOA_RR}" $((${Verbose_Level}))

    if [ ${#Dns_Zone_RR} -eq 0 ]; then
        Dns_Zone_RR=${Dns_Zone_SOA_RR}
    else
        if [ "${Dns_Zone_RR}" != "${Dns_Zone_SOA_RR}" ]; then
            if [ "${Dns_Zone_RR}" == "22.172.in-addr.arpa" ]; then
                Dns_Zone_RR=${Dns_Zone_SOA_RR}
            else
                dnsAlert "dns zone '${Dns_Zone_RR}' does NOT match SOA '${Dns_Zone_SOA_RR}'"
                Dns_Zone_RR=${Dns_Zone_SOA_RR}
            fi
        fi
    fi

    if [ ${#Dns_Zone_RR} -eq 0 ]; then
        dnsAlert "can't determine dns zone for '${Dns_FQDN_RR}'"
        Dns_RC=1
        continue
    fi

    verbose "Dns_Zone_RR=${Dns_Zone_RR} [VALID]" $((${Verbose_Level}))

    #
    # validate dns zone key
    #

    if Dns_Zone_Keyfile_RR=$(dnsZoneKeyfile "${Dns_Zone_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_View_RR}"); then
        Dns_Zone_Key_RR=${Dns_Zone_Keyfile_RR##*,}
        Dns_Zone_Keyfile_RR=${Dns_Zone_Keyfile_RR%%,*}
    else
        dnsAlert "can't determine dns zone key for '${Dns_FQDN_RR}'"
        continue
    fi

    verbose "Dns_Zone_Key_RR=${Dns_Zone_Key_RR}" ${Verbose_Level}
    verbose "Dns_Zone_Keyfile_RR=${Dns_Zone_Keyfile_RR}" ${Verbose_Level}

    if [ ${Force_Flag} -eq 0 ] || [ "${Dns_Action}" == "check" ] || [ "${Dns_Action}" == "update" ]; then
        Dns_Add_RR=1
        Dns_Delete_RR=1
        Dns_Update_RR=0
    else
        if [ "${Dns_Action}" == "add" ]; then
            Dns_Add_RR=0
        else
            Dns_Add_RR=1
        fi
        if [ "${Dns_Action}" == "delete" ]; then
            Dns_Delete_RR=0
        else
            Dns_Delete_RR=1
        fi
        Dns_Update_RR=1
    fi

    #Dns_Status_RR="[${Dns_Action^^}]: server ${Dns_Server_IP_RR}, record for ${Dns_FQDN_RR} ${Dns_Data_RR} ${Dns_RR} = "
    Dns_Status_RR="[CHECK]: server ${Dns_Server_IP_RR}, ${Dns_FQDN_RR} ${Dns_RR} = "

    Dns_Status=${Dns_Status_RR}
    if dnsLookup match "${Dns_RR}" "${Dns_FQDN_RR}" "${Dns_Data_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}"; then
        Dns_Status+="${Dns_Data_RR} "
        if [ ${Force_Flag} -eq 0 ]; then
            verbose "${Dns_Status} [MATCH; FORCE]" ${Verbose_Level}
            Dns_Add_RR=0
            Dns_Delete_RR=0
        else
            if [ ${Dns_Add_RR} -eq 0 ]; then
                verbose "${Dns_Status} [MATCH; ADD]" ${Verbose_Level}
                Dns_Add_RR=1
            else
                if [ ${Dns_Delete_RR} -eq 0 ]; then
                    verbose "${Dns_Status} [MATCH; DELETE]" ${Verbose_Level}
                else
                    if [ ${Dns_Update_RR} -eq 0 ]; then
                        verbose "${Dns_Status} [MATCH; UPDATE]" ${Verbose_Level}
                    fi
                fi
            fi
        fi
    else
        if dnsLookup exist "${Dns_RR}" "${Dns_FQDN_RR}" "${Dns_Data_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}"; then
            Dns_Status+="$(dnsLookup value "${Dns_RR}" "${Dns_FQDN_RR}" "${Dns_Data_RR}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}") "
            if [ ${Force_Flag} -eq 0 ]; then
                verbose "${Dns_Status} [MISMATCH; FORCE]" ${Verbose_Level}
                Dns_Add_RR=0
                Dns_Delete_RR=0
            else
                if [ ${Dns_Add_RR} -eq 0 ]; then
                    verbose "${Dns_Status} [MISMATCH; ADD]" ${Verbose_Level}
                    Dns_Add_RR=1
                else
                    if [ ${Dns_Delete_RR} -eq 0 ]; then
                        verbose "${Dns_Status} [MISMATCH; DELETE]" ${Verbose_Level}
                        Dns_Delete_RR=1
                    else
                        if [ ${Dns_Update_RR} -eq 0 ]; then
                            verbose "${Dns_Status} [MISMATCH; UPDATE]" ${Verbose_Level}
                            Dns_Add_RR=0
                            Dns_Delete_RR=0
                        fi
                    fi
                fi
            fi
        else
            Dns_Status+="${Dns_Data_RR} "
            if [ ${Force_Flag} -eq 0 ]; then
                verbose "${Dns_Status} [MISSING; FORCE]" ${Verbose_Level}
                Dns_Add_RR=0
            else
                if [ ${Dns_Add_RR} -eq 0 ]; then
                    verbose "${Dns_Status} [MISSING; ADD]" ${Verbose_Level}
                else
                    if [ ${Dns_Delete_RR} -eq 0 ]; then
                        verbose "${Dns_Status} [MISSING; DELETE]" ${Verbose_Level}
                        Dns_Delete_RR=1
                    else
                        if [ ${Dns_Update_RR} -eq 0 ]; then
                            verbose "${Dns_Status} [MISSING; UPDATE]" ${Verbose_Level}
                            Dns_Add_RR=0
                        fi
                    fi
                fi
            fi
        fi
    fi

    verbose "Dns_Update_RR=${Dns_Update_RR}" ${Verbose_Level}
    verbose "Dns_Delete_RR=${Dns_Delete_RR}" ${Verbose_Level}
    verbose "Dns_Add_RR=${Dns_Add_RR}" ${Verbose_Level}

    Dns_Action_RRS=()

    if [ ${Dns_Delete_RR} -eq 0 ]; then
        Dns_Action_RRS+=(delete)
        Dns_Status+=" [DELETE]"
    fi

    if [ ${Dns_Add_RR} -eq 0 ]; then
        Dns_Action_RRS+=(add)
        Dns_Status+=" [ADD]"
    fi

    if [ ${Dns_Delete_RR} -eq 1 ] && [ ${Dns_Add_RR} -eq 1 ]; then
        if [ "${Dns_Action}" == "check" ]; then
            Dns_Status+=" [OK]"
        else
            Dns_Status+=" [BYPASS]"
        fi
    fi

    dnsEcho "${Dns_Status}"

    if [ "${Dns_Action}" == "check" ]; then
        continue
    fi

    if [ ${Dns_Delete_RR} -eq 1 ] && [ ${Dns_Add_RR} -eq 1 ]; then
        continue
    fi

    #
    # validation complete
    #

    for Dns_Action_RR in "${Dns_Action_RRS[@]}"; do
        if dnsRR "${Dns_Action_RR}" "${Dns_RR}" "${Dns_FQDN}" "${Dns_Data}" "${Dns_Data_Priority}" "${Dns_Data_TTL}" "${Dns_Server_IP_RR}" "${Dns_Server_Port_RR}" "${Dns_Zone_RR}" "${Dns_Zone_Arpa}" "${Dns_Zone_Key_RR}" "${Dns_Zone_Keyfile_RR}"; then
            verbose "[SUCCESS] ${0} ${Arguments}" ${Verbose_Level}
        else
            dnsAlert "[FAILED] ${0} ${Arguments}"
        fi
    done

    if [ ${Rndc_Flag} -eq 0 ]; then
        if [ "${Dns_Server_IP_RR}" == "127.0.0.1" ] || [ "${Dns_Server_IP_RR}" == "::1" ]; then
            rndc sync -clean &> /dev/null
            if [ $? -ne 0 ]; then
                dnsAlert "rndc sync -clean FAILED"
            fi
        fi
    fi

    if [ ${All_Flag} -ne 0 ]; then
        break
    fi
done

#
# End dns
#

if [ "${BASH_SOURCE}" != "${0}" ]; then
    return ${Dns_RC}
else
    exit ${Dns_RC}
fi
